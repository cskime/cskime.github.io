<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Iterable collections | cskime.io</title>
<meta name="keywords" content="dart, iterable, collections, document reading">
<meta name="description" content="Iterable collections Dart 문서 읽기
Collection과 Iterable Collection : element의 집합을 표현하는 객체 (e.g. List, Set, Map)
Iterable : element에 순차적으로 접근할 수 있는 collection의 한 종류
Iterable abstract class를 상속받은 List, Set 등을 통해 Iterable 객체 생성
Map은 key를 사용해서 value를 얻는 방식으로 Iterable이 아님. 단, entries나 values 속성을 통해 key 또는 value group을 Iterable 객체로 읽을 수 있음
Iterable과 List는 element에 접근하는 방법에 차이가 있음
List는 [index] operator를 사용하지만, Iterable은 elementAt(index) method를 사용해서 특정 index의 element에 접근">
<meta name="author" content="">
<link rel="canonical" href="https://cskime.github.io/posts/iterable-collections/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://cskime.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cskime.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cskime.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cskime.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://cskime.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://cskime.github.io/posts/iterable-collections/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Iterable collections" />
<meta property="og:description" content="Iterable collections Dart 문서 읽기
Collection과 Iterable Collection : element의 집합을 표현하는 객체 (e.g. List, Set, Map)
Iterable : element에 순차적으로 접근할 수 있는 collection의 한 종류
Iterable abstract class를 상속받은 List, Set 등을 통해 Iterable 객체 생성
Map은 key를 사용해서 value를 얻는 방식으로 Iterable이 아님. 단, entries나 values 속성을 통해 key 또는 value group을 Iterable 객체로 읽을 수 있음
Iterable과 List는 element에 접근하는 방법에 차이가 있음
List는 [index] operator를 사용하지만, Iterable은 elementAt(index) method를 사용해서 특정 index의 element에 접근" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cskime.github.io/posts/iterable-collections/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-08-17T13:37:39+09:00" />
<meta property="article:modified_time" content="2024-08-17T13:37:39+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Iterable collections"/>
<meta name="twitter:description" content="Iterable collections Dart 문서 읽기
Collection과 Iterable Collection : element의 집합을 표현하는 객체 (e.g. List, Set, Map)
Iterable : element에 순차적으로 접근할 수 있는 collection의 한 종류
Iterable abstract class를 상속받은 List, Set 등을 통해 Iterable 객체 생성
Map은 key를 사용해서 value를 얻는 방식으로 Iterable이 아님. 단, entries나 values 속성을 통해 key 또는 value group을 Iterable 객체로 읽을 수 있음
Iterable과 List는 element에 접근하는 방법에 차이가 있음
List는 [index] operator를 사용하지만, Iterable은 elementAt(index) method를 사용해서 특정 index의 element에 접근"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://cskime.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Iterable collections",
      "item": "https://cskime.github.io/posts/iterable-collections/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Iterable collections",
  "name": "Iterable collections",
  "description": "Iterable collections Dart 문서 읽기\nCollection과 Iterable Collection : element의 집합을 표현하는 객체 (e.g. List, Set, Map)\nIterable : element에 순차적으로 접근할 수 있는 collection의 한 종류\nIterable abstract class를 상속받은 List, Set 등을 통해 Iterable 객체 생성\nMap은 key를 사용해서 value를 얻는 방식으로 Iterable이 아님. 단, entries나 values 속성을 통해 key 또는 value group을 Iterable 객체로 읽을 수 있음\nIterable과 List는 element에 접근하는 방법에 차이가 있음\nList는 [index] operator를 사용하지만, Iterable은 elementAt(index) method를 사용해서 특정 index의 element에 접근",
  "keywords": [
    "dart", "iterable", "collections", "document reading"
  ],
  "articleBody": " Iterable collections Dart 문서 읽기\nCollection과 Iterable Collection : element의 집합을 표현하는 객체 (e.g. List, Set, Map)\nIterable : element에 순차적으로 접근할 수 있는 collection의 한 종류\nIterable abstract class를 상속받은 List, Set 등을 통해 Iterable 객체 생성\nMap은 key를 사용해서 value를 얻는 방식으로 Iterable이 아님. 단, entries나 values 속성을 통해 key 또는 value group을 Iterable 객체로 읽을 수 있음\nIterable과 List는 element에 접근하는 방법에 차이가 있음\nList는 [index] operator를 사용하지만, Iterable은 elementAt(index) method를 사용해서 특정 index의 element에 접근\nIterable\u003cint\u003e iterable = [1, 2, 3]; print(iterable.elementAt(1)); // 2 List\u003cint\u003e list = [1, 2, 3]; print(list[1]); // 2 elementAt()은 index까지 다른 element들을 무시함 (step through)\nReading elements for-in loop : Iterable을 순회하며 element 읽기 const iterable = [\"Salad\", \"popcorn\"]; for (final element in iterable) { print(element); } first and last : Iterable의 첫 번째 또는 마지막 element 읽기 Iterable\u003cString\u003e iterable = const [\"Salad\", \"Popcorn\", \"Toast\"]; iterable.first; // Salad iterable.last; // Toast Empty Iterable에서 사용하면 StateError 발생 firstWhere(predicate) : 특정 조건을 만족하는 첫 번째 element 읽기 const items = [\"Salad\", \"Popcorn\", \"Toast\", \"Lasagne\"]; final element = iterable.firstWhere( (element) =\u003e element.length \u003e 5, orElse: () =\u003e \"None!\", ); print(element); // Popcorn predicate 함수에서 조건을 검사하여 true를 반환하는 첫 번째 element 반환 조건에 만족하는 element를 찾지 못하면, StateError 발생 orElse 함수를 전달하면 이 함수가 반환하는 값을 반환 singleWhere(predicate) : 특정 조건을 단 한번만 만족하는 element 읽기 const items = [\"Salad\", \"Popcorn\", \"Milk\", \"Toast\", \"Lasagne\"]; final element = items.singleWhere( (element) =\u003e element.startsWith(\"M\") \u0026\u0026 element.contains(\"a\"), ); print(element); // Milk firstWhere()는 조건에 맞는 element를 찾으면 종료 singleWhere()는 Iterable의 모든 element를 순회하므로 infinite 또는 element가 아주 많은 Iterable에서 사용하면 StateError가 발생할 수 있음 Checking conditions every(predicate) : 모든 element가 predicate 조건을 만족할 때 true 반환 final isValid = items.every((item) =\u003e item.length \u003e= 5); any() : predicate 조건을 만족하는 element가 최소 1개 이상일 때 true 반환 const items = [\"Salad\", \"Popcorn\", \"Toast\"]; final any = items.any((item) =\u003e item.contains(\"a\")); // true (Salad or Toast) final every = items.every((item) =\u003e item.length \u003e= 5); // any()는 조건을 만족하는 element가 1개라도 있으면 true를 반환 any()를 조건을 만족하는 element가 없다는 것을 검증할 때도 사용 가능 (false를 반환하는 경우) Filtering elements where() : 특정 조건을 만족하는 모든 element를 찾아서 새 Iterable(WhereIterable)로 만들어 반환 final evenNumbers = numbers.where((number) =\u003e number.isEven); firstWhere()나 singleWhere()는 조건을 만족하는 element 1개를 찾는다는 차이가 있다. 조건에 맞는 element가 없다면 empty Iterable 반환 (firstWhere()와 달리 StateError를 발생시키지 않음) takeWhile(predicate) : predicate에서 false를 반환하기 이전 element들을 모아서 새 Iterable로 반환 const numbers = [1, 3, -2, 0, 4, 5]; final numbersUntilZero = numbers.takeWhile((number) =\u003e number != 0); print(numbersUntilZero); // [1, 3, -2] skipWhile() : predicate에서 false를 반환한 이후 element들을 모아서 새 Iterable로 반환 const numbers = [1, 3, -2, 0, 4, 5]; final numbersUntilZero = numbers.skipWhile((number) =\u003e number != 0); print(numbersUntilZero); // [0, 4, 5] predicate에서 false를 반환하는 element를 찾으면 이후 element에 대해서는 조건을 검사하지 않음 Mapping elements map() : Iterable의 각 element들을 새로운 값으로 교체 Iterable\u003cint\u003e output = numbers.map((number) =\u003e number * 10); Other APIs 문서에서 소개한 함수 외에 Iterable 객체에서 사용할 수 있는 유용한 함수들\nfold() const items = [\"Salad\", \"Popcorn\", \"Milk\", \"Toast\", \"Lasagne\"]; final count = items.fold(0, (previous, element) =\u003e previous + element.length); print(count); // 28 = 5 + 7 + 4 + 5 + 7 collection의 element들을 initialValue와 연산하여 하나의 값으로 합침 다른 언어의 reduce 함수 reduce() const items = [1, 2, 3]; final sum = items.reduce((value, element) =\u003e value + element); print(sum); // 6 fold와 같은 역할이지만, initialValue 없이 collection의 element들을 가지고 연산 다른 언어의 reduce와 달리 결과 type이 원본 collection type으로 고정되어 있음 Collection이 비어있다면 IterableElementError 발생 forEach() const items = [\"Salad\", \"Popcorn\", \"Toast\"]; items.forEach(print); // Salad, Popcorn, Toast 각 element들에 대해 함수 실행 join() const numbers = [1, 2, 3]; final result = numbers.join(\"-\"); print(result); // 1-2-3 Element를 String type으로 변환한 뒤 separator로 연결(concatenate) contains() const items = [\"Salad\", \"Popcorn\", \"Toast\"]; items.contains(\"Toast\"); // true items.contains(\"Milk\"); // false Iterable에 element가 들어 있는지 판단 Dart의 모든 값은 객체이므로 Object type parameter로 전달 가능 take(count) const items = [\"Salad\", \"Popcorn\", \"Milk\", \"Toast\", \"Lasagne\"]; final result = items.take(3); print(result); // [Salad, Popcorn, Milk] Iterable의 element들 중 처음 count개의 element를 모아서 lazy iterable 생성 내부적으로 iterator가 count개의 element를 읽은 후에야 iterable을 생성 skip(count) const items = [\"Salad\", \"Popcorn\", \"Milk\", \"Toast\", \"Lasagne\"]; final result = items.skip(3); print(result); // [Toast, Lasagne] Iterable의 element들 중 처음 count개의 element를 제외한 나머지 element들을 모아서 iterable 생성 ",
  "wordCount" : "709",
  "inLanguage": "en",
  "datePublished": "2024-08-17T13:37:39+09:00",
  "dateModified": "2024-08-17T13:37:39+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cskime.github.io/posts/iterable-collections/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "cskime.io",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cskime.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cskime.github.io/" accesskey="h" title="cskime.io (Alt + H)">cskime.io</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://cskime.github.io/archive" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://cskime.github.io/tags" title="tags">
                    <span>tags</span>
                </a>
            </li>
            <li>
                <a href="https://cskime.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Iterable collections
    </h1>
    <div class="post-meta"><span title='2024-08-17 13:37:39 +0900 KST'>August 17, 2024</span>&nbsp;·&nbsp;4 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#collection%ea%b3%bc-iterable" aria-label="Collection과 Iterable">Collection과 Iterable</a></li>
                <li>
                    <a href="#reading-elements" aria-label="Reading elements">Reading elements</a></li>
                <li>
                    <a href="#checking-conditions" aria-label="Checking conditions">Checking conditions</a></li>
                <li>
                    <a href="#filtering-elements" aria-label="Filtering elements">Filtering elements</a></li>
                <li>
                    <a href="#mapping-elements" aria-label="Mapping elements">Mapping elements</a></li>
                <li>
                    <a href="#other-apis" aria-label="Other APIs">Other APIs</a><ul>
                        
                <li>
                    <a href="#fold" aria-label="fold()">fold()</a></li>
                <li>
                    <a href="#reduce" aria-label="reduce()">reduce()</a></li>
                <li>
                    <a href="#foreach" aria-label="forEach()">forEach()</a></li>
                <li>
                    <a href="#join" aria-label="join()">join()</a></li>
                <li>
                    <a href="#contains" aria-label="contains()">contains()</a></li>
                <li>
                    <a href="#takecount" aria-label="take(count)">take(count)</a></li>
                <li>
                    <a href="#skipcount" aria-label="skip(count)">skip(count)</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p><a href="https://dart.dev/libraries/collections/iterables#example-using-first-and-last">Iterable collections</a> Dart 문서 읽기</p>
</blockquote>
<hr>
<h2 id="collection과-iterable">Collection과 Iterable<a hidden class="anchor" aria-hidden="true" href="#collection과-iterable">#</a></h2>
<ul>
<li>
<p><strong>Collection</strong> : element의 집합을 표현하는 객체 (e.g. <code>List</code>, <code>Set</code>, <code>Map</code>)</p>
</li>
<li>
<p><strong>Iterable</strong> : element에 순차적으로 접근할 수 있는 collection의 한 종류</p>
<ul>
<li>
<p><code>Iterable</code> abstract class를 상속받은 <code>List</code>, <code>Set</code> 등을 통해 <code>Iterable</code> 객체 생성</p>
</li>
<li>
<p><code>Map</code>은 key를 사용해서 value를 얻는 방식으로 <code>Iterable</code>이 아님. 단, <code>entries</code>나 <code>values</code> 속성을 통해 key 또는 value group을 <code>Iterable</code> 객체로 읽을 수 있음</p>
</li>
<li>
<p><code>Iterable</code>과 <code>List</code>는 element에 접근하는 방법에 차이가 있음</p>
<ul>
<li>
<p><code>List</code>는 <code>[index]</code> operator를 사용하지만, <code>Iterable</code>은 <code>elementAt(index)</code> method를 사용해서 특정 index의 element에 접근</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span>Iterable<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> iterable <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>print(iterable.elementAt(<span style="color:#ae81ff">1</span>)); <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>print(list[<span style="color:#ae81ff">1</span>]); <span style="color:#75715e">// 2
</span></span></span></code></pre></div></li>
<li>
<p><code>elementAt()</code>은 <code>index</code>까지 다른 element들을 무시함 (step through)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="reading-elements">Reading elements<a hidden class="anchor" aria-hidden="true" href="#reading-elements">#</a></h2>
<ol>
<li><code>for-in</code> loop : <code>Iterable</code>을 순회하며 element 읽기
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> iterable <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;popcorn&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">final</span> element <span style="color:#66d9ef">in</span> iterable) {
</span></span><span style="display:flex;"><span>    print(element);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li><code>first</code> and <code>last</code> : <code>Iterable</code>의 첫 번째 또는 마지막 element 읽기
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span>Iterable<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">String</span><span style="color:#f92672">&gt;</span> iterable <span style="color:#f92672">=</span> <span style="color:#66d9ef">const</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>];
</span></span><span style="display:flex;"><span>iterable.first; <span style="color:#75715e">// Salad
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>iterable.last; <span style="color:#75715e">// Toast
</span></span></span></code></pre></div><ul>
<li>Empty <code>Iterable</code>에서 사용하면 <code>StateError</code> 발생</li>
</ul>
</li>
<li><code>firstWhere(predicate)</code> : 특정 조건을 만족하는 첫 번째 element 읽기
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>, <span style="color:#e6db74">&#34;Lasagne&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> element <span style="color:#f92672">=</span> iterable.firstWhere(
</span></span><span style="display:flex;"><span>    (element) <span style="color:#f92672">=&gt;</span> element.length <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>    orElse: () <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">&#34;None!&#34;</span>,
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>print(element); <span style="color:#75715e">// Popcorn
</span></span></span></code></pre></div><ul>
<li><code>predicate</code> 함수에서 조건을 검사하여 <code>true</code>를 반환하는 첫 번째 element 반환</li>
<li>조건에 만족하는 element를 찾지 못하면,
<ul>
<li><code>StateError</code> 발생</li>
<li><code>orElse</code> 함수를 전달하면 이 함수가 반환하는 값을 반환</li>
</ul>
</li>
</ul>
</li>
<li><code>singleWhere(predicate)</code> : 특정 조건을 <strong>단 한번만</strong> 만족하는 element 읽기
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Milk&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>, <span style="color:#e6db74">&#34;Lasagne&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> element <span style="color:#f92672">=</span> items.singleWhere(
</span></span><span style="display:flex;"><span>    (element) <span style="color:#f92672">=&gt;</span> element.startsWith(<span style="color:#e6db74">&#34;M&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> element.contains(<span style="color:#e6db74">&#34;a&#34;</span>),
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>print(element); <span style="color:#75715e">// Milk
</span></span></span></code></pre></div><ul>
<li><code>firstWhere()</code>는 조건에 맞는 element를 찾으면 종료</li>
<li><code>singleWhere()</code>는 <code>Iterable</code>의 모든 element를 순회하므로 infinite 또는 element가 아주 많은 <code>Iterable</code>에서 사용하면 <code>StateError</code>가 발생할 수 있음</li>
</ul>
</li>
</ol>
<h2 id="checking-conditions">Checking conditions<a hidden class="anchor" aria-hidden="true" href="#checking-conditions">#</a></h2>
<ol>
<li><code>every(predicate)</code> : 모든 element가 <code>predicate</code> 조건을 만족할 때 <code>true</code> 반환
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> isValid <span style="color:#f92672">=</span> items.every((item) <span style="color:#f92672">=&gt;</span> item.length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">5</span>);
</span></span></code></pre></div></li>
<li><code>any()</code> : <code>predicate</code> 조건을 만족하는 element가 최소 1개 이상일 때 <code>true</code> 반환
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> any <span style="color:#f92672">=</span> items.any((item) <span style="color:#f92672">=&gt;</span> item.contains(<span style="color:#e6db74">&#34;a&#34;</span>)); <span style="color:#75715e">// true (Salad or Toast)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> every <span style="color:#f92672">=</span> items.every((item) <span style="color:#f92672">=&gt;</span> item.length <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">5</span>); <span style="color:#75715e">//
</span></span></span></code></pre></div><ul>
<li><code>any()</code>는 조건을 만족하는 element가 1개라도 있으면 <code>true</code>를 반환</li>
<li><code>any()</code>를 <strong>조건을 만족하는 element가 없다는 것을 검증</strong>할 때도 사용 가능 (<code>false</code>를 반환하는 경우)</li>
</ul>
</li>
</ol>
<h2 id="filtering-elements">Filtering elements<a hidden class="anchor" aria-hidden="true" href="#filtering-elements">#</a></h2>
<ol>
<li><code>where()</code> : 특정 조건을 만족하는 모든 element를 찾아서 새 <code>Iterable</code>(<code>WhereIterable</code>)로 만들어 반환
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> evenNumbers <span style="color:#f92672">=</span> numbers.where((number) <span style="color:#f92672">=&gt;</span> number.isEven);
</span></span></code></pre></div><ul>
<li><code>firstWhere()</code>나 <code>singleWhere()</code>는 조건을 만족하는 element 1개를 찾는다는 차이가 있다.</li>
<li>조건에 맞는 element가 없다면 empty <code>Iterable</code> 반환 (<code>firstWhere()</code>와 달리 <code>StateError</code>를 발생시키지 않음)</li>
</ul>
</li>
<li><code>takeWhile(predicate)</code> : <code>predicate</code>에서 <code>false</code>를 반환하기 이전 element들을 모아서 새 <code>Iterable</code>로 반환
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> numbersUntilZero <span style="color:#f92672">=</span> numbers.takeWhile((number) <span style="color:#f92672">=&gt;</span> number <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>print(numbersUntilZero); <span style="color:#75715e">// [1, 3, -2]
</span></span></span></code></pre></div></li>
<li><code>skipWhile()</code> : <code>predicate</code>에서 <code>false</code>를 반환한 이후 element들을 모아서 새 <code>Iterable</code>로 반환
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> numbersUntilZero <span style="color:#f92672">=</span> numbers.skipWhile((number) <span style="color:#f92672">=&gt;</span> number <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>print(numbersUntilZero); <span style="color:#75715e">// [0, 4, 5]
</span></span></span></code></pre></div><ul>
<li><code>predicate</code>에서 <code>false</code>를 반환하는 element를 찾으면 이후 element에 대해서는 조건을 검사하지 않음</li>
</ul>
</li>
</ol>
<h2 id="mapping-elements">Mapping elements<a hidden class="anchor" aria-hidden="true" href="#mapping-elements">#</a></h2>
<ol>
<li><code>map()</code> : <code>Iterable</code>의 각 element들을 새로운 값으로 교체
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span>Iterable<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> output <span style="color:#f92672">=</span> numbers.map((number) <span style="color:#f92672">=&gt;</span> number <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>);
</span></span></code></pre></div></li>
</ol>
<h2 id="other-apis">Other APIs<a hidden class="anchor" aria-hidden="true" href="#other-apis">#</a></h2>
<p>문서에서 소개한 함수 외에 <code>Iterable</code> 객체에서 사용할 수 있는 유용한 함수들</p>
<h3 id="fold"><code>fold()</code><a hidden class="anchor" aria-hidden="true" href="#fold">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Milk&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>, <span style="color:#e6db74">&#34;Lasagne&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> count <span style="color:#f92672">=</span> items.fold(<span style="color:#ae81ff">0</span>, (previous, element) <span style="color:#f92672">=&gt;</span> previous <span style="color:#f92672">+</span> element.length);
</span></span><span style="display:flex;"><span>print(count); <span style="color:#75715e">// 28 = 5 + 7 + 4 + 5 + 7
</span></span></span></code></pre></div><ul>
<li>collection의 element들을 <code>initialValue</code>와 연산하여 하나의 값으로 합침</li>
<li>다른 언어의 reduce 함수</li>
</ul>
<h3 id="reduce"><code>reduce()</code><a hidden class="anchor" aria-hidden="true" href="#reduce">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> sum <span style="color:#f92672">=</span> items.reduce((value, element) <span style="color:#f92672">=&gt;</span> value <span style="color:#f92672">+</span> element);
</span></span><span style="display:flex;"><span>print(sum); <span style="color:#75715e">// 6
</span></span></span></code></pre></div><ul>
<li><code>fold</code>와 같은 역할이지만, <code>initialValue</code> 없이 collection의 element들을 가지고 연산</li>
<li>다른 언어의 reduce와 달리 결과 type이 원본 collection type으로 고정되어 있음</li>
<li>Collection이 비어있다면 <code>IterableElementError</code> 발생</li>
</ul>
<h3 id="foreach"><code>forEach()</code><a hidden class="anchor" aria-hidden="true" href="#foreach">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>];
</span></span><span style="display:flex;"><span>items.forEach(print); <span style="color:#75715e">// Salad, Popcorn, Toast
</span></span></span></code></pre></div><ul>
<li>각 element들에 대해 함수 실행</li>
</ul>
<h3 id="join"><code>join()</code><a hidden class="anchor" aria-hidden="true" href="#join">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> numbers <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> result <span style="color:#f92672">=</span> numbers.join(<span style="color:#e6db74">&#34;-&#34;</span>);
</span></span><span style="display:flex;"><span>print(result); <span style="color:#75715e">// 1-2-3
</span></span></span></code></pre></div><ul>
<li>Element를 <code>String</code> type으로 변환한 뒤 <code>separator</code>로 연결(concatenate)</li>
</ul>
<h3 id="contains"><code>contains()</code><a hidden class="anchor" aria-hidden="true" href="#contains">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>];
</span></span><span style="display:flex;"><span>items.contains(<span style="color:#e6db74">&#34;Toast&#34;</span>); <span style="color:#75715e">// true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>items.contains(<span style="color:#e6db74">&#34;Milk&#34;</span>); <span style="color:#75715e">// false
</span></span></span></code></pre></div><ul>
<li><code>Iterable</code>에 <code>element</code>가 들어 있는지 판단</li>
<li>Dart의 모든 값은 객체이므로 <code>Object</code> type parameter로 전달 가능</li>
</ul>
<h3 id="takecount"><code>take(count)</code><a hidden class="anchor" aria-hidden="true" href="#takecount">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Milk&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>, <span style="color:#e6db74">&#34;Lasagne&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> result <span style="color:#f92672">=</span> items.take(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>print(result); <span style="color:#75715e">// [Salad, Popcorn, Milk]
</span></span></span></code></pre></div><ul>
<li><code>Iterable</code>의 element들 중 처음 <code>count</code>개의 element를 모아서 lazy iterable 생성</li>
<li>내부적으로 iterator가 <code>count</code>개의 element를 읽은 후에야 iterable을 생성</li>
</ul>
<h3 id="skipcount"><code>skip(count)</code><a hidden class="anchor" aria-hidden="true" href="#skipcount">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dart" data-lang="dart"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> items <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;Salad&#34;</span>, <span style="color:#e6db74">&#34;Popcorn&#34;</span>, <span style="color:#e6db74">&#34;Milk&#34;</span>, <span style="color:#e6db74">&#34;Toast&#34;</span>, <span style="color:#e6db74">&#34;Lasagne&#34;</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> result <span style="color:#f92672">=</span> items.skip(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>print(result); <span style="color:#75715e">// [Toast, Lasagne]
</span></span></span></code></pre></div><ul>
<li><code>Iterable</code>의 element들 중 처음 <code>count</code>개의 element를 제외한 나머지 element들을 모아서 iterable 생성</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://cskime.github.io/tags/dart/">Dart</a></li>
      <li><a href="https://cskime.github.io/tags/iterable/">Iterable</a></li>
      <li><a href="https://cskime.github.io/tags/collections/">Collections</a></li>
      <li><a href="https://cskime.github.io/tags/document-reading/">Document Reading</a></li>
    </ul>
  </footer>
<div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
  
  
  
  };
  (function() {
      if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
          document.getElementById('disqus_thread').innerHTML = 'Disqu s comments not available by default when the website is previewed locally.';
          return;
      }
      var d = document, s = d.createElement('script'); s.async = true;
      s.src = '//' + "cskime-github-io" + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
  })();
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript
>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a
>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://cskime.github.io/">cskime.io</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
