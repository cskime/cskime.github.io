[{"content":"나는 iOS 개발자로 일하다가 지난 해 퇴사 후 안식년을 갖고 있다. 쉬는 동안 개발자라는 직업에 대한 고민을 많이 하고 있다. 나는 어떤 개발자가 되고 싶은지 방향성을 잃어가고 있다는 생각이 들었기 때문이다. 개발하는 것 자체는 즐거운 일이지만 개발자라는 직업이 정말 나와 맞는지, 개발자를 오래 할 수 있을지 확신이 들지 않았다. 그래서, 쉬는 동안 다양한 개발 분야를 넓게 경험해보면서 생각을 정리해보기로 했다.\niOS 모바일 개발을 주로 했던 나는 아예 다른 분야를 경험해보고 싶어서 웹 개발을 배워보기로 했다. 최근에는 개발을 배울 수 있는 곳이 많아져서 어디서 개발을 배워야 하는지 정하는게 더 어려웠는데, 노마드코더의 강의 스타일과 챌린지 시스템이 마음에 들어서 노마드 코더를 선택했다. 이 때, 노마드코더의 10주 스터디 프로그램을 알게 되었는데 웹 풀스택 개발을 빠르게 경험해볼 수 있다는 것과 어딘가 소속되어 공부할 수 있다는 장점을 보고 웹 10주 스터디에 참여했었다.\n웹 개발은 흥미가 오래 가지 못했지만, 노마드코더의 10주 스터디는 빠르게 관련 지식들을 흡수하고 경험해 볼 수 있는 가장 좋은 선택지인 것 같다는 생각이 들었다. 그래서, 웹 개발 다음으로 iOS 개발자로 일할 때 크로스플랫폼에 관심을 가지며 알게 된 Flutter를 배워보기로 결정했을 때에도 망섬일 없이 노마드코더의 Flutter 스터디를 선택했다. Flutter 스터디에 포함된 틱톡 클론 강의와 애니메이션 마스터 강의는 스터디를 통해서만 할 수 있는 챌린지가 있었는데, 이 챌린지들 덕분에 Flutter로 앱을 만드는 것에 더 쉽고 빠르게 익숙해질 수 있었다. 스터디 동안 만든 챌린지 결과물이 약 20개 정도 되는데, 꾸준히 강의를 따라가며 만들었던 결과물들을 10주가 지나고 나서 돌아보니 \u0026ldquo;두달 반이 허투루 흘러간건 아니구나\u0026rdquo; 라는 생각이 든다.\nFlutter 10주 스터디에서 만든 것들 어떤 사람들은 클론 코딩에 대해서 부정적으로 말하기도 한다. 클론 코딩 강의를 보면서 따라 치기만 하면 실력이 늘지 않는다는 것이다. 그런데, 노마드코더의 클론 코딩은 챌린지 덕분에 더 빛을 발하는 것 같다. 챌린지 과제들은 어떻게 보면 스크린샷만 던져주고 \u0026ldquo;이거 만들어\u0026quot;라고 말하는 것 같아 불친절하게 느껴질 수 있지만, 오히려 그런 점이 배우는 입장에서 생각할 거리를 던져주고 더 깊이 고민할 수 있게 만들어 준다는 점에서 장점이 된다. 개발자로 일하던 때를 생각해 보면, 기획 요구사항과 디자인 시안을 받아서 개발하는 프로세스와 꽤 비슷한 경험을 해볼 수 있는 것 같다.\n스터디의 또 다른 장점 중 하나는 스터디원들과 TA 분들을 통해 꾸준히 동기부여를 받을 수 있다는 점이다. 스터디에서는 강제하진 않지만 공개된 채널에 매일 일일 스프린트를 작성하고 매주 주간회고를 작성해서 제출하는데, 다른 스터디원 분들이 일일 스프린트와 주간회고를 작성해 주시고 꾸준히 공부하는 모습을 보면서 가끔 슬럼프가 찾아와도 방향을 잃어버리지 않고 10주를 버텨낼 수 있었다. 이런 시스템 없이 혼자 공부했다면 4~5주차 쯤에는 계획이고 뭐고 흐지부지되고 나태해 졌을 것이다. 혹시 노마드코더에서 공부하기로 결정했다면, 가능하면 스터디에 참여하는 것을 강력 추천한다.\n스터디가 끝난 뒤, 챌린지와 과제를 돌려보며 배웠던 내용을 정리하고 지식의 해상도를 높이는 시간을 가지려고 한다. 그 이후의 계획은 아직 세우지 않았다. Flutter로 취업을 할 수도 있고, Flutter로 평소에 쌓아 두었던 아이디어를 실제로 만들어 볼 수도 있고, 또 다른 분야의 개발 공부를 시작할 수도 있고, 다시 iOS 개발자로 돌아가기 위해 이제는 어색해져버린 Swift와 iOS 개발 공부를 다시 시작할 수도 있다. 하지만, 다시 원래 일로 돌아가더라도 다양한 언어와 프레임워크를 학습한 경험을 바탕으로 더 나은 개발자가 될 수 있을 거라고 생각한다.\n그래서 결론.\n개발에 빠르게 익숙해지고 싶다면 노마드코더 강의를 추천한다. 공부를 하면서도 잘 하고 있는건지 모르겠고, 배운 것을 내 것으로 만들기 어렵다면 챌린지와 함께 공부하는 것을 추천한다. 혼자 공부하기 힘들다면 스터디에 참여하는 것을 추천한다. ","permalink":"https://cskime.github.io/posts/nomadcoders-flutter-study-review/","summary":"나는 iOS 개발자로 일하다가 지난 해 퇴사 후 안식년을 갖고 있다. 쉬는 동안 개발자라는 직업에 대한 고민을 많이 하고 있다. 나는 어떤 개발자가 되고 싶은지 방향성을 잃어가고 있다는 생각이 들었기 때문이다. 개발하는 것 자체는 즐거운 일이지만 개발자라는 직업이 정말 나와 맞는지, 개발자를 오래 할 수 있을지 확신이 들지 않았다. 그래서, 쉬는 동안 다양한 개발 분야를 넓게 경험해보면서 생각을 정리해보기로 했다.\niOS 모바일 개발을 주로 했던 나는 아예 다른 분야를 경험해보고 싶어서 웹 개발을 배워보기로 했다.","title":"Nomadcoders Flutter 10주 스터디 후기"},{"content":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod # needed when you reclone your repo (submodules may not get cloned automatically) $ git submodule update --init --recursive Theme update $ git submodule update --remote --merge hugo.yaml에 theme 명시 (구 config.yaml)\ntheme: [\u0026#34;PageMod\u0026#34;] Customizing \u0026lt;img\u0026gt; tag로 post에 image 추가하기 참고 : PaperMod and Hugo tweaks\nhugo.yaml에 아래 설정 추가 markup: goldmark: renderer: unsafe: true # 이 설정이 없으면 \u0026lt;img\u0026gt; tag를 사용할 수 없다. Markdown 문법(![]())을 사용하면 이 설정이 없어도 되지만 image size를 조절할 수 없다. Post 구조를 아래와 같이 변경 contents ㄴ posts ㄴ post-1 ㄴ index.md ㄴ image.jpg Markdown 안에서 \u0026lt;img\u0026gt; tag로 image 추가 \u0026lt;img src=\u0026#34;./image.jpg\u0026#34; width=\u0026#34;300\u0026#34; /\u0026gt; Menu /content 경로에 menu page를 markdown file로 생성 Archive page 설정 Search page 설정 hugo.yaml에 menu 설정 추가 (참고) Deploy to GitHub Repository 두 개 생성 (실제로 website로 보여지는 파일들은 /public에 있으므로 저장소 분리)\nblog source : blog source를 upload할 repository {username}.github.io : public directory를 upload할 repository Remote repo로 추가\n# blog source repository $ git remote add origin https://github.com/username/blog-source.git # public directory만 submodule로 따로 관리 $ git submodule add -b main https://github.com/username/username.github.io.git public # Submodule 등록 확인 $ ll .git/modules submodule에 theme과 public directory 두 개가 등록되어 있다면 정상적으로 등록된 것 만약, fatal: 'public' already exists and is not a valid git repo 과 같은 error가 발생하면 public 폴더를 삭제한 뒤 재시도 Root와 /public에서 각각 git remote -v를 실행하면 서로 다른 repository가 등록되어 있는 것을 확인 배포 script\n블로그를 배포할 때 blog-source와 {username}.github.io 두 repository에 각각 push해야 함 배포 과정을 script로 작성해서 사용 (참고) Reference Hugo Documentation PaperMod\u0026rsquo;s Demo hugo-PaperMod WiKi PaperMod 테마를 Hugo 사이트에 적용하는 방법 Hugo 블로그 생성 과정 (theme PaperMod) ","permalink":"https://cskime.github.io/posts/github-pages-hugo-papermod-blog/","summary":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.","title":"GitHub Pages와 Hugo PaperMod 테마로 블로그 만들기"},{"content":"개발 동기 노마드코더 챌린지 과제 중 아래와 같은 text UI를 구현하는 부분이 있었다. 회원가입 중 이용 약관이나 개인 정보 처리 방침 등을 사용자에게 안내하고 관련 외부 문서로 이동하여 확인할 수 있게 만드는 보편적인 UI 이다.\nFlutter에서 text에 다양한 style을 적용할 때 RichText 또는 Text.rich를 사용하므로, 이 UI를 구현하기 위해 아래와 같이 코드를 작성했다.\n이렇게 코드를 작성하면 몇 가지 문제가 있다.\n다른 style을 사용할 text를 직접 분류해서 나누어 작성해야 하므로 실수할 가능성이 있다. TextSpan이 중첩되는 구조이므로 어떤 text에 다른 style을 적용하는지 직관적으로 파악하기 어려워서 요구사항이 바뀌면 유지보수하기 어렵다. TextSpan을 어떻게, 얼마나 중첩시켜야 하는지에 대한 기준이 없다. 코드를 일관되게 작성하기 어렵다. 첫 번째 TextSpan.children에 다른 모든 TextSpan을 넣어도 동작에 차이가 없으므로, 사람에 따라 다른 style로 코드를 작성하게 된다. 만약, grouping 할 목적으로 두 번 이상 중첩한다면 indent depth가 깊어져 가독성이 떨어진다. 이런 문제를 해결하고 최대한 단순하고 직관적으로 구현할 수 있는 방법을 고민해 보다가, 이런 종류의 text UI를 쉽게 만들 수 있는 widget을 직접 만들어보기로 했다.\n설계 아래 세 가지 단계로 개발할 수 있게 되는 것을 목표로 한다.\n전체 문장을 주고, style을 바꾸고 싶은 단어 목록을 전달하면, 전체 문장에서 해당 단어들을 찾아 지정한 style 적용 이를 위해, text를 rendering하는 widget은 constructor를 통해 아래 속성을 초기화한다.\ntext : 전체 text (String type) words : style을 바꾸고 싶은 단어 목록 여기서 words는 List\u0026lt;Word\u0026gt; type의 값을 받는다. Word 객체는 constructor로 두 가지 값을 초기화한다.\ntext : 단어 (String type) style : 단어에 적용할 style 결과적으로, 아래와 같이 사용하는 것을 목표로 한다.\nMyTextWidget( text: \u0026#34;This is an entire text.\u0026#34;, words: [ Word(text: \u0026#34;entire\u0026#34;, style: TextStyle(~)), Word(text: \u0026#34;text\u0026#34;, style: TextStyle(~)), ], ) 개발 과정 1차 개발 처음에는 특정 단어를 선택하면 그에 해당하는 외부 web page로 이동할 수 있도록 개발했다.\n단어에 하이퍼링크를 추가하는 것임을 나타내기 위해 Link라는 class를 만들고, 해당 단어를 선택했을 때 외부에서 web page로 이동하는 코드를 작성할 수 있도록 constructor를 통해 callback 함수를 등록하도록 개발했다. 그리고, 전체 text와 하이퍼링크를 걸 단어 목록 List\u0026lt;Link\u0026gt;를 전달받아 Link에 해당하는 단어들에 style을 입히고 callback 함수를 등록해 주는 LinkableText class를 구현했다.\nLinkableText은 아래 과정을 거쳐 Link.text에 해당하는 단어들에 style을 적용하고 callback을 등록한다.\nlinks로 전달된 단어들을 순회하며 전체 text에서 해당 단어들의 위치(index) 저장 Index를 기준으로 links를 오름차순 정렬 links로 전달하는 단어들이 전체 text에 나타나는 순서와 다른 경우를 고려하여 정렬 정렬된 단어들을 순회하며 전체 text를 기준으로 split Split된 단어들과 links 단어들을 번갈아가며 List\u0026lt;TextSpan\u0026gt;에 저장 생성된 List\u0026lt;TextSpan\u0026gt;으로 Text.rich를 만들어서 반환 최종적으로 구현된 LinkableText와 Link는 아래와 같이 사용할 수 있다.\n2차 개발 LinkableText는 대부분의 경우 의도한 대로 잘 동작하지만, links에 같은 단어가 두 번 이상 들어있는 경우 특정 위치의 단어에만 style을 적용하기 어렵다는 단점이 있었다. 가령, 두 번째 나타나는 단어에만 style을 적용하려는 경우에도 첫 번째 나타나는 단어가 links에 들어있어야 한다. Style을 적용하지 않을 단어는 links에 추가하지 않았으면 좋겠다.\n또, “Link”라는 이름에 비해 기능이 너무 추상적이기도 했다. URL에 대한 하이퍼링크를 만드는게 아니라, text에 부분적으로 style을 적용하고 tap 할 수 있는 기능을 추가하는 것에 가깝다.\n이런 문제점을 개선하고 더 범용적으로 사용될 수 있도록 추상화한 CustomizableText widget을 개발하고, style을 더 세밀하게 변경할 수 있도록 인터페이스를 추가했다.\n변경 사항은 아래와 같다.\n이름에서 “link” 제거 LinkableText → CustomizableText links → customizes Link → CustomText span (new) callback → onTap Style을 설정할 수 있는 속성 추가 (아래로 갈 수록 style이 override 된다.) CustomizableText.style : 전체 text에 적용되는 style CustomizableText.customStyle : 전체 custom text들에 적용되는 style CustomText.style : custom text 1개에 적용되는 style 특정 위치의 text에만 style을 적용할 수 있도록 개선 span 값을 사용해서 특정 위치의 단어에만 style을 적용할 수 있도록 개선했다. span으로 전체 text에서 두 번 이상 나타나는 단어 중 임의의 위치에 있는 단어를 식별할 수 있다. 이 기능은 기존 LinkableText에서 style을 적용하지 않을 단어까지 links에 넣어야 하는 문제를 해결한다. 내부 정렬 알고리즘을 개선했습니다. Before : Map으로 단어 별 index들을 기록한 뒤 정렬 After : allMatches method를 사용해서 단어들의 정렬된 index를 얻음 Closing CustomizableText를 사용하여 위와 같은 text UI를 직관적이고 쉽게 그릴 수 있었다. CustomizableText는 어떤 프로젝트에서도 다양하게 활용될 수 있을 것 같아서 pub.dev에 배포하는 경험도 할 수 있었다. (customizable_text package | pub.dev)\n배포를 하고 나서 개선할 것들이 더 눈에 띄었다. pub.dev에 패키지를 올리면 score가 매겨지는데, documentation이 부족하여 만점을 받지 못했다. Package로 만든 이상, API documentation을 제대로 해 두는게 필요해 보였다. 또, tap 외에도 long press 등 다른 gesture에 대한 callback을 추가할 수 있으면 더 좋을 것 같다. Static color가 아닌 gradient나 shadow 등 다른 형태의 style을 입힐 수 있게 만들어도 좋을 것 같다.\n","permalink":"https://cskime.github.io/posts/customizable_text_package_review/","summary":"개발 동기 노마드코더 챌린지 과제 중 아래와 같은 text UI를 구현하는 부분이 있었다. 회원가입 중 이용 약관이나 개인 정보 처리 방침 등을 사용자에게 안내하고 관련 외부 문서로 이동하여 확인할 수 있게 만드는 보편적인 UI 이다.\nFlutter에서 text에 다양한 style을 적용할 때 RichText 또는 Text.rich를 사용하므로, 이 UI를 구현하기 위해 아래와 같이 코드를 작성했다.\n이렇게 코드를 작성하면 몇 가지 문제가 있다.\n다른 style을 사용할 text를 직접 분류해서 나누어 작성해야 하므로 실수할 가능성이 있다.","title":"Flutter Package 개발 기록 - customizable_text"},{"content":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider? of(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;CounterProvider\u0026gt;(); } 공유 상태를 관리하기 위한 StatefulWidget 생성\nclass CounterScope extends StatefulWidget { const CounterScope({ super.key, required this.child, }); final Widget child; @override State\u0026lt;CounterScope\u0026gt; createState() =\u0026gt; _CounterScopeState(); } class _CounterScopeState extends State\u0026lt;CounterScope\u0026gt; { // ✅ 실제 상태 값 관리 : 상태 저장 및 갱신(setState) int counter = 0; void incrementCounter() { setState(() { counter++; }); } @override Widget build(BuildContext context) { return CounterProvider( counter: counter, incrementCounter: incrementCounter, child: widget.child, ); } } MyApp의 home에서 CounterScope를 HomeScreen의 상위 widget으로 추가\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ CounterScope가 HomeScreen의 상위 widget이 됨 home: const CounterScope(child: HomeScreen()), ); } } 문제 재현 HomeScreen에서는 CounterProvider에 접근할 수 있음\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: ..., body: Center( child: CountLabel( counter: CounterProvider.of(context)?.counter ?? -1, // ✅ ), ), floatingActionButton: IncrementButton( onPressed: CounterProvider.of(context)?.incrementCounter, // ✅ ), ); } } Navigator.push로 DetailScreen으로 이동\n// 버튼 callback onPressed: () =\u0026gt; Navigator.of(context).push( MaterialPageRoute( builder: (context) =\u0026gt; const DetailScreen(), ), ), DetailScreen에서는 CounterProvider에 접근할 수 없음\n// 버튼 callback class DetailScreen extends StatelessWidget { const DetailScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;Detail Page\u0026#39;), ), body: Center( child: CountLabel( // ❌ : null을 반환하므로 label에 \u0026#39;-1\u0026#39; 표시 counter: CounterProvider.of(context)?.counter ?? -1, ), ), floatingActionButton: IncrementButton( // ❌ : null을 반환하므로 counter가 동작하지 않음 onPressed: CounterProvider.of(context)?.incrementCounter, ), ); } } 원인 분석 InheritedWidget에 접근하는 방식 BuildContext.dependOnInheritedWidgetOfExactType은 현재 widget에서 widget tree상의 상위 widget을 찾아서 반환함 즉, BuildContext.dependOnInheritedWidgetOfExactType이 null이면 widget tree에서 상위에InheritedWidget이 존재하지 않는다는 것 Navigator.of(context).push의 동작 방식 MaterialApp은 내부에서 Navigator를 만들고 widget tree에 추가한다. MaterialApp.home에 전달하는 widget은 이 최상위 Navigator의 child widget이 된다. MaterialApp ㄴ Navigator ㄴ HomeScreen Widget에서 Navigator.of(context)을 호출하면 MaterialApp이 생성한 최상위 Navigator를 얻는다. Screen A에서 screen B로 Navigator.push를 통해 화면을 전환하면, 최상위 Navigator의 하위에 screen B를 추가하며 화면에 렌더링한다. 즉, screen A와 B는 같은 root Navigator에 의해 sibling 관계로 widget tree에 추가된다. 문제 발생 원인 Widget tree를 열어보면 DetailScreen과 CounterProvider가 ancestor-descendant 관계가 아닌 sibling 관계인 것을 확인할 수 있음 BuildContext.dependOnInheritedWidgetOfExactType는 widget tree상의 ancestor InheritedWidget을 찾는 것이므로, sibling 관계에서는 접근할 수 없다. HomeScreen에서는 CounterProvider가 direct ancestor widget이기 때문에 CounterProvider에 정상적으로 접근할 수 있었다. 해결 방법 CounterProvider와 DetailScreen을 ancestor-descendant 관계로 만들어 준다.\nHomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 (MaterialApp 위) HomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 관련 코드\nHomeScreen을 아래와 같이 수정한다.\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { // ✅ HomeScreen 하위에 Navigator 추가 // 이제 `Navigator.of(context)`는 이 Navigator를 반환한다. return Navigator( onGenerateRoute: (settings) =\u0026gt; MaterialPageRoute( builder: (context) =\u0026gt; ..., // 원래 widget 덩어리 반환 ), ); } } HomeScreen의 build() method에서 Navigator를 반환한다. Navigator의 onGenerateRoute 함수에서 MaterialPageRoute를 반환한다. MaterialPageRoute의 builder 함수에서 HomeScreen을 구성하는 Scaffold widget 덩어리를 반환한다. 이제 HomeScreen에서 Navigator.of(context)를 호출하면 최상위 Navigator가 아닌 HomeScreen의 하위 Navigator를 사용하므로 DetailScreen이 HomeScreen의 child widget으로 추가된다. InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 관련 코드\nDetailScreen이 MaterialApp 아래에서 InheritedWidget을 child로 갖는 HomeScreen과 sibling 관계를 갖는 것이 문제이므로, InheritedWidget을 MaterialApp의 상위 widget으로 올려서 HomeScreen과 DetailScreen의 공통 ancestor widget이 될 수 있게 만든다.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { // ✅ CounterScope와 CounterProvider가 MaterialApp보다 상위 widget이 된다. return CounterScope( child: MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ `HomeScreen`을 감싸고 있던 CounterScope는 제거한다. home: const HomeScreen(), ), ); } } 이제 HomeScreen과 DetailScreen이 sigling 관계여도 CounterProvider를 공통 ancestor로 가지므로, 두 widget 모두 BuildContext를 통해 CounterProvider에 접근할 수 있다.\n결론 Navigator.of(context)는 MaterialApp이 만드는 최상위 Navigator에 접근한다. Navigator.push는 route widget을 Navigator의 child로 추가한다. 여러 화면에서 공통으로 사용되는 state는 navigation 이후 widget tree 구조를 고려해서 위치시켜야 한다. Navigator를 직접 추가하는 방법은 history를 모르면 예상치 못한 버그가 발생할 우려가 있으므로, InheritedWidget을 Navigator보다 상위에 위치시키는 방법이 더 좋아 보인다. Riverpod에서 ProviderScope가 runApp 바로 아래에서 MyApp을 wrapping하게 만드는 이유를 조금이나마 이해했다. ProviderScope는 내부 build() method에서 InheritedWidget을 상속받는 UncontrolledProviderScope를 반환한다. Riverpod도 비슷한 문제를 해결하기 위해 최상위에 InheritedWidget을 놓으려는 시도를 한 것 같다. 참고 Navigator class | flutter.io MaterialApp class | flutter.io ","permalink":"https://cskime.github.io/posts/inherited-widget-unaccessible/","summary":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider?","title":"Navigator.push로 띄운 route에서 InheritedWidget에 접근할 수 없는 문제"},{"content":"Hit Testing Hit test는 사용자 event가 발생할 때 view 계층(hierarchy)에서 subview들을 탐색(traverse)하며 event를 처리할 view를 결정하는 과정이다. Root view부터 시작하여 subview들을 역방향으로 탐색하며, event 발생 위치(point)를 포함하는 view가 있다면 그 view의 subview들을 같은 방법으로 탐색해 나간다.\n\u0026lsquo;역방향\u0026rsquo;으로 탐색하는 이유는, 화면의 가장 앞에 위치한 view부터 탐색하기 위함이다. 여러 개의 view가 겹쳐있다면 사용자가 보게 되는 맨 앞의 view가 event를 가져가야 한다. 화면의 가장 앞에 있는 view는 다음과 같은 특징을 가진다.\nz-order index(depth)가 가장 크다. 형제 view(sibling view)들 중에서 subview index가 가장 크다. Tree 구조에서 이와 같은 탐색 방법을 **역방향 깊이 우선 탐색(Reverse Pre-Order Depth-First Traversal)**이라고 한다.\n아래 그림은 touch event가 발생했을 때 event를 처리할 view를 결정하는 과정을 보여준다.\nView 계층의 root view(UIWindow)부터 시작하여 touch point를 포함하는 subview들 중 가장 멀리 떨어진 view를 탐색한다. MainView의 subview들 중 index가 가장 큰 View C부터 탐색을 시작한다. View C는 touch point를 포함하지 않으므로 건너뛰고, View B를 탐색한다. View B는 touch point를 포함하고 있으므로, 그 subview들 중 index가 가장 큰 View B.2를 탐색한다. View B.2는 touch point를 포함하지 않으므로 건너뛰고, view B.1을 탐색한다. View B.1은 touch point를 포함하고 root로부터 가장 멀리 떨어진 view이므로, View B.2에 event를 전달한다. Hit Test 구현 Hit testing에서 event를 전달받을 후보 view가 되기 위해서는 다음 조건을 만족해야 한다.\nView가 화면에 보여야 한다. View가 user interaction이 가능해야 한다. View 영역이 event 발생 위치(point)를 포함해야 한다. View 계층에서 세 가지 조건을 만족하는 view를 찾기 위해 hitTest(_:with:) 함수를 다음과 같이 구현할 수 있다. 함수가 nil을 반환하는 것은 event를 받을 수 없는 view이므로 다음 view를 탐색하라는 의미이다.\nfunc hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // 1번 조건 검사 guard !isHidden, alpha \u0026gt; 0.01 else { return nil } // 2번 조건 검사 guard isUserInteractionEnabled else { return nil } // 역방향 탐색을 위해 subviews array를 뒤집어서(reversed) 탐색 for subview in subviews.reversed() { let point = subview.convert(point, from: self) guard let hitView = subview.hitTest(point, with: event) else { continue } // 재귀적으로 반환되는 hitView는 곧 subview를 의미한다. // 즉, subview에서 hit testing이 성공하면 subview가 자기 자신을 반환할 것이다. return hitView } // 3번 조건 검사 guard bounds.contains(point) else { return nil } return self } UIView에는 이런 방식으로 구현된 hitTest(_:with:) method가 이미 구현되어 있다. 만약, 어떤 view가 특정 조건에서 event를 수신하지 못하게 하려면 다음과 같이 override해서 사용할 수 있다.\nclass SomeView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // somCondition이 true일 때만 이 view에서 hit testing을 계속한다. guard someCondition else { return nil } return super.hitTest(point, with: event) } } 활용 Hit testing에서 반환되는 view를 조작하여 특정 상황에서만 event를 받을 수 있도록 구현할 수 있다.\n1. Passing through touch event 아래와 같이 5개의 UISwitch가 파란색 view로 덮여 있다. 스위치를 터치하더라도, 덮고 있는 view가 event를 가져가므로 스위치를 on/off할 수 없다.\n이 상황에서 스위치를 터치해서 on/off할 수 있게 만들려면, cover view에 event가 전달되지 않아야 하므로 event를 받기 위한 3가지 조건 중 한 가지를 만족하지 않도록 바꾸면 된다.\nUser interaction 비활성화 coverView.isUserInteractionEnabled = false View 숨김(Cover view가 반드시 보여야한다면, 이 방법은 사용하지 못할 것이다.) coverView.isHidden = true // or coverView.alpha = 0 hitTest(_:with:) 함수에서 nil 반환 class CoverView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { return nil } } 만약 특정 스위치만 on/off할 수 있게 만들려면 hitTest(_:with:) method를 override해서 nil을 반환하는 조건을 추가로 구현해야 한다.\nclass CoverView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { var hitView = super.hitTest(point, with: event) // 가운데 스위치가 있는 영역 let rect = bounds.insetBy(dx: bounds.width / 3, dy: bounds.height / 3) // Point가 가운데 영역(rect)에 포함될 때는 nil을 반환한다. guard rect.contains(point) else { return hitView } return nil } } 2. Throw touch event Hit testing을 통해 event를 받는 view는 hitTest(_:with:) method에서 반환되는 view이다. 즉, 실제로는 event를 받기 위한 3가지 조건을 만족하지 못하는 어떤 view를 임의로 hitTest(_:with:)에서 반환시키면 그 view도 event를 받아 처리할 수 있게 된다.\n다음은 이 방법을 사용하여 크기가 작은 버튼의 터치 영역을 확장시키는 예시이다.\nclass CustomButton: UIButton { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // Button 영역에서 상하좌우 10pt만큼 더 넓은 영역까지 touch point를 검사한다. let contains = bounds.insetBy(dx: -10, dy: -10).contains(point) return contains ? super.hitTest(point, with: event) : nil } } Reference http://smnh.me/hit-testing-in-ios/ https://developer.apple.com/documentation/uikit/uiview/1622469-hittest ","permalink":"https://cskime.github.io/posts/ios-hit-testing/","summary":"Hit Testing Hit test는 사용자 event가 발생할 때 view 계층(hierarchy)에서 subview들을 탐색(traverse)하며 event를 처리할 view를 결정하는 과정이다. Root view부터 시작하여 subview들을 역방향으로 탐색하며, event 발생 위치(point)를 포함하는 view가 있다면 그 view의 subview들을 같은 방법으로 탐색해 나간다.\n\u0026lsquo;역방향\u0026rsquo;으로 탐색하는 이유는, 화면의 가장 앞에 위치한 view부터 탐색하기 위함이다. 여러 개의 view가 겹쳐있다면 사용자가 보게 되는 맨 앞의 view가 event를 가져가야 한다. 화면의 가장 앞에 있는 view는 다음과 같은 특징을 가진다.\nz-order index(depth)가 가장 크다.","title":"iOS Hit Testing"}]