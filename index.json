[{"content":"Overview Dart에서 JSON을 parsing하는 class를 만들 때 fromJson이라는 factory named constructor를 만들곤 한다.\nclass Person { final String name; final int age; Person({required this.name, required this.age}); // ✅ factory Person.fromJson(Map\u0026lt;String, dynamic\u0026gt; json) =\u0026gt; Person(name: json[\u0026#34;name\u0026#34;], age: json[\u0026#34;age\u0026#34;]); } 그런데, fromJson constructor는 factory가 아니어도 아무 문제가 없다.\nclass Person { final String name; final int age; Person({required this.name, required this.age}); // ✅ Person.fromJson1(Map\u0026lt;String, dynamic\u0026gt; json) : name = json[\u0026#34;name\u0026#34;], age = json[\u0026#34;age\u0026#34;]; } Dart 문서의 예시에서도 fromJson을 factory constructor로 만들고 있다.\nclass Logger { // ... factory Logger(String name) { return _cache.putIfAbsent(name, () =\u0026gt; Logger._internal(name)); } // Logger.fromJson factory constructor initializes a final variable from a JSON object. factory Logger.fromJson(Map\u0026lt;String, Object\u0026gt; json) { return Logger(json[\u0026#39;name\u0026#39;].toString()); } // ... } 왜 fromJson constructor는 factory로 만들라고 하는 것일까?\nFactory constructor Dart 문서에서 factory constructor는 아래의 경우에 해당되면 사용하라고 설명하고 있다. Constructor가 subtype instance를 생성하거나, cache 등에서 이미 존재하는 instance를 가져와서 반환하는 경우 Argument 검사 또는 initializer list에서 처리되지 않은 작업 등 instance 생성 과정에서 선행되어야 하는 중요한 작업을 수행해야 하는 경우 함께 소개된 예시 코드에서 Logger constructor는 cache에서 객체를 가져와서 반환하므로 factory constructor를 사용하면 좋다. 하지만, Logger.fromJson은 json object로부터 name data를 가져와서 Logger instance를 생성하고 있다. Json을 parsing하는 과정에서 선행되는 작업도 없고, json data를 사용해서 \u0026lsquo;항상\u0026rsquo; 새 instance를 만들어서 반환하는데 왜 factory constructor로 만드는 것일까? Defensive design Stack overflow에서 관련된 질문과 답변을 찾을 수 있었다. Factory constructor를 사용하는 것은 기술적으로 특별한 이유가 없더라도 defensive design을 위한 것이라고 한다. 일반적인 generative constructor를 만들면 subclass에서 forwarding이 가능해 진다. 이 constructor에 validation code를 추가하는 등의 변경이 필요하면 factory constructor로 변경해야 하는데, 이 class를 상속받는 subclass들 중 constructor를 forwarding 하고 있던 class에서 예상하지 못한 error가 발생할 가능성이 생긴다. 따라서, fromJson 외에도 constructor는 먼저 factory로 만들고 필요할 때만 public generative constructor를 만드는게 안전하다고 한다. Conclusion Stack overflow의 답변에 따르면, factory constructor를 사용하는 이유는 subclass에서 의도하지 않은 forwarding에 의한 error 가능성을 제거하는 목적이다. 하지만, 이것보다는 json 객체를 parsing하는 constructor의 역할 때문인 것 같다. 간단한 json 객체는 특별히 다른 logic이 필요없어 보이지만, 일반적으로 json 객체를 parsing할 때는 실패할 가능성이 존재하므로 이와 관련된 방어 코드 등의 logic이 필요할 수 있다. 따라서, json 객체로부터 instance를 생성하는 constructor는 factory constructor를 사용해야 하는 두 번째 이유에 해당한다고 생각한다. 이 질문에 대한 답은 정해진 것이 없으므로, fromJson은 일반적인 구현 패턴을 따라 factory constructor로 만드는게 좋을 것 같다. Reference Why use factory when constructing a new instance from a map structure? | Stack Overflow Constructors - Factory constructors | dart.dev ","permalink":"https://cskime.github.io/posts/why-from-json-factory/","summary":"Overview Dart에서 JSON을 parsing하는 class를 만들 때 fromJson이라는 factory named constructor를 만들곤 한다.\nclass Person { final String name; final int age; Person({required this.name, required this.age}); // ✅ factory Person.fromJson(Map\u0026lt;String, dynamic\u0026gt; json) =\u0026gt; Person(name: json[\u0026#34;name\u0026#34;], age: json[\u0026#34;age\u0026#34;]); } 그런데, fromJson constructor는 factory가 아니어도 아무 문제가 없다.\nclass Person { final String name; final int age; Person({required this.name, required this.age}); // ✅ Person.fromJson1(Map\u0026lt;String, dynamic\u0026gt; json) : name = json[\u0026#34;name\u0026#34;], age = json[\u0026#34;age\u0026#34;]; } Dart 문서의 예시에서도 fromJson을 factory constructor로 만들고 있다.","title":"[Dart] fromJson constructor는 왜 factory로 만들까?"},{"content":" Dart isolate 관련 문서들을 참고하여 isolate의 개념 및 동작방식을 요약한다. 참고한 문서 Concurrency in Dart | dart.dev Isolates | dart.dev Concurrency and isolates | Flutter docs Isolate 사용 이유 모든 Dart code는 기본적으로 main isolate에서 실행된다. Main isolates의 event loop는 UI paint, I/O, user input 등 UI 관련 event들을 처리한다. Main isolate에서 시간이 오래 걸리는 작업을 실행하면 event loop가 다음 repaint event 처리 시점을 놓치게 되면서 UI freezing이 발생할 수 있다. 이 문제를 해결하기 위해 시간이 오래 걸리는 작업을 다른 isolate에서 실행시키고, 작업 완료 시 결괏값을 비동기적으로 반환 받아서 사용한다. Isolate들은 memory가 완벽하게 격리되어 있고 자신만의 event loop도 갖고 있으므로, 다른 worker isolate에서 오래된 작업을 실행해도 main isolate에 영향을 주지 않는다. Isolate 특징 Isolate는 일반적인 thread와 비슷한 개념이지만, thread와 달리 isolate들이 shared memory 없이 완벽하게 격리(isolated) 되어 있다는 차이가 있다. Isolate 간에 shared memory가 없으므로, isolate 간의 communication은 반드시 message channel을 통해야 한다. (ReceivePort, SendPort 사용) global mutable variable, static field 등도 isolate 별로 분리되어 있다. shared state가 존재하지 않는다. State를 변경해도 isolate간 동기화가 이루어지지 않으므로 message를 통해 직접 동기화 시켜야 한다. UI 관련 작업들은 main isolate에서만 처리할 수 있으므로, 다른 isolate에서 rootBundle을 통해 asset에 접근하거나 Flutter widget 등 UI와 관련된 코드를 실행시킬 수 없다. 다른 isolate를 만들 때 spawner isolate와 new isolate는 같은 isolate group으로 묶여서 더 빠르고 효율적으로 message를 주고받을 수 있다. Isolate 사용 방법 Isolate.run Isolate.run(computation)을 사용해서 instant worker isolate를 생성하고 computation 함수를 실행시킨다.\nWorker isolate에서 computation을 실행한 결괏값은 Future 반환한다.\n실행이 끝난 worker isolate는 사용 중지된다.\nExample\nconst String filename = \u0026#39;with_keys.json\u0026#39;; void main() async { // Read some data. final jsonData = await Isolate.run(() async { final fileData = await File(filename).readAsString(); final jsonData = jsonDecode(fileData) as Map\u0026lt;String, dynamic\u0026gt;; return jsonData; }); // Use that data. print(\u0026#39;Number of JSON keys: ${jsonData.length}\u0026#39;); } Isolate.spawn Worker isolate와 여러 개의 message들을 지속적으로 주고받고 싶다면 Isolate.spawn(entryPoint,message)을 사용해서 isolate를 생성한다.\nReceivePort와 SendPort class 객체를 생성해서 message channel을 직접 구현해 준다. ReceivePort.listen으로 다른 isolate가 보낸 message를 받는 listener를 등록해 두고, SendPort로 다른 isolate에 message를 보낸다.\nReceivePort와 SendPort의 동작을 Stream에 비유할 수 있다.\nReceivePort : listener of a stream SendPort : StreamController Isolate 사용이 끝나면 ReceivePort.close()로 port를 닫은 뒤 isolate.kill(priority?) 또는 Isolate.exit으로 worker isolate를 제거한다.\nExample: Worker class\nclass Worker { late SendPort _sendPort; final Completer\u0026lt;void\u0026gt; _isolateReady = Completer.sync(); Future\u0026lt;void\u0026gt; spawn async { // 1. Create a ReceivePort on the main isolate final receivePort = ReceivePort() // 2. Add a listener to handle messages from the worker isolate receivePort.listen(_handleResponsesFromIsolate); // 3. Create a worker isolate // `_startReomteIsolate` is a `entryPoint` function. It executes at the first time. // Pass the SendPort to the worker isolate as an initial message await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort); } void _handleResponsesFromIsolate(dynamic message) { if (message is SendPort) { // 1. First message from the worker isolate should be SendPort _sendPort = message; _isolateReady.complete(); } else if (message is Map\u0026lt;String, dynamic\u0026gt;) { print(message); } } static void _startRemoteIsolate(SendPort port) { // 1. Create ReceivePort on the worker isolate final receivePort = ReceivePort(); // 2. Pass the SendPort to the main isolate as an initial message port.send(receivePort.sendPort); // 3. Add a listener to handle messages from the main isolate receivePort.listen((message) async { if (message is String) { final transformed = jsonDecode(message); port.send(transformed); } }); } Future\u0026lt;void\u0026gt; parseJson(String message) async { // 1. Wait until main isolate receives a SendPort from the worker isolate await _isolateReady.future; // 2. Send a message to the worker isolate _sendPort.send(message); } } Example 2: RawReceivePort를 사용해서 connection logic 분리하기\nReceivePort는 내부적으로 broadcast가 아닌 stream을 사용하기 때문에 listen으로 1개의 listener만 등록 가능 그래서, 위 코드에는 worker isolate로부터 message를 받아서 처리하는 logic에 두 가지 작업이 섞여 있다. SendPort를 받아서 message channel을 만드는 작업 실제 message를 받아서 처리하는 작업 이 때, RawReceivePort를 사용해서 port setup logic과 message handling logic을 분리할 수 있다. RawReceivePort의 handler에 worker isolate로부터 SendPort를 받아서 connection을 만들고 Completer를 사용해서 작업을 완료시키는 함수 등록 final initPort = RawReceivePort(); final connection = Completer\u0026lt;(ReceivePort, SendPort)\u0026gt;.sync(); initPort.handler = (initialMessage) { final commandPort = initialMessage as SendPort; connection.complete(( ReceivePort.fromRawReceivePort(initPort), // ReceivePort로 변환 commandPort, )); }; SendPort를 받아 connection이 만들어진 뒤 ReceivePort.listen으로 실제로 사용하는 message들만 처리하는 listener 등록 receivePort.listen((message) { // Listener를 등록하기 전에 `RawReceivePort.handler`에서 이미 SendPort를 받았으므로 // message가 `SendPort`인지 검사하지 않아도 된다. final jsonData = jsonDecode(message as String); sendPort.send(jsonData); }); RawReceivePort.handler와 ReceivePort.listen의 차이 RawReceivePort.handler : message를 받을 때 호출되는 일반적인 callback function ReceivePort.listen : StreamSubscription을 반환하여 Stream 관련 API 활용 가능 ","permalink":"https://cskime.github.io/posts/isolate-summary/","summary":"Dart isolate 관련 문서들을 참고하여 isolate의 개념 및 동작방식을 요약한다. 참고한 문서 Concurrency in Dart | dart.dev Isolates | dart.dev Concurrency and isolates | Flutter docs Isolate 사용 이유 모든 Dart code는 기본적으로 main isolate에서 실행된다. Main isolates의 event loop는 UI paint, I/O, user input 등 UI 관련 event들을 처리한다. Main isolate에서 시간이 오래 걸리는 작업을 실행하면 event loop가 다음 repaint event 처리 시점을 놓치게 되면서 UI freezing이 발생할 수 있다.","title":"[Dart] Isolate 요약"},{"content":"Overview 이 글은 Understanding null safety 문서의 내용을 바탕으로 Dart에서 null safety가 나온 배경 및 null safety의 동작 방식을 쉽게 이해하기 위해 작성하였다. 기본 문법적인 설명들을 제외하고 null safety의 원리를 이해하는데 필요하다고 생각되는 부분들만 정리했기 때문에 원문의 일부 내용이 누락되어 있고 설명하는 순서도 다르다. 빠르게 Dart null safety의 동작 방식에 대해 이해하는 것이 목적이라면 이 글을 이해하는 것으로 충분하겠지만, 더 자세한 설명이 필요하다면 원문을 정독하는 것을 권한다. Null safety가 나온 이유 Dart에서 null은 Null type으로 표현된다. Null safety 도입 전에는 Dart type system에서 Null이 다른 모든 type들의 subtype 이었다. 그래서 type에 상관 없이 변수에 null을 할당할 수 있었다. String value = \u0026#34;hello\u0026#34;; value = null; 이렇게 동작할 때 문제는 어떤 변수에 할당된 값이 null인지 아닌지 명확하게 알 수 없다는 것이다. 만약 변수에 null이 할당된 것을 모르고 해당 변수의 값을 참조하면 runtime에 null reference exception이 발생하며 app이 crash 될 것이다. String value = null; value.length; // ❌ : null reference error Null safety는 nullable한 변수를 null-safe하게 참조할 수 있는 방법을 제공한다. Nullable type과 non-nullable type Null safety는 Dart type system의 구조를 변경하여 Null type이 다른 type들의 subtype이 아닌 독립적인 type으로 존재하도록 하여 문제를 해결한다. 여기서 Null에 독립적으로 type graph를 이루는 type들을 non-nullable type으로 분류한다. Non-nullable type들은 Null type과 연관이 없으므로 절대로 null 값을 가질 수 없다. null값을 가질 수 있는 type들은 nullable type으로 분류한다. Nullable type은 underlying type과 Null type의 supertype으로, underlying type 뒤에 ? mark를 붙여서 표현한다. 이것은 nullable type이 non-null 또는 null 값 모두 가질 수 있음을 의미한다. 즉, null safety 도입 이후 Dart의 type은 아래와 같이 nullable type과 non-nullable type 두 그룹으로 분류된다. Type promotion과 null safety Type promotion Type promotion이란, if 등 control flow에서 is 연산자로 어떤 변수의 type을 특정할 수 있으면 control flow body 안에서 해당 변수의 type을 is로 검사한 type으로 취급(promote)하는 것을 말한다. bool isEmptyList(Object object) { if (object is List) { return object.isEmpty; // ✅ : `object`가 `List` type인 것을 안다. } else { return false; } } Null safety가 도입되기 전의 type promotion은 제한적이어서, 아래와 같이 is! 연산자를 사용한 반대 상황에서는 동작하지 않았다. // Without null safety: bool isEmptyList(Object object) { if (object is! List) return false; return object.isEmpty; // ❌ } Null safety를 도입하기 전에는 object가 List type이라는 것을 Dart가 알지 못했기 때문에 위 코드는 실행되지 못했다. Null safety에 type promotion을 도입하기 전에, 이러한 type promotion의 한계를 먼저 해결했다. 따라서, 위 코드가 동작하려면 null safety를 사용해야 한다. Null safety를 도입한 후에는 개선된 type promotion을 사용하여 위 코드가 정상적으로 실행될 수 있다. // Using null safety: bool isEmptyList(Object object) { if (object is! List) return false; return object.isEmpty; // ✅ : `object`가 `List` type인 것을 안다. } 기존 type promotion이 early return 및 unreachable code path에 대해서 잘 동작하지 않았던 문제가 개선됐다. 개선된 type promotion은 return, break, throw 및 함수에서 early terminate로 동작하는 code를 인식한다. Type promotion on null checks Type promotion이 is 연산자 외에 == null 및 != null 구문을 통한 null check도 인식하도록 기능이 추가되었다.\n// Using null safety: String makeCommand(String executable, [List\u0026lt;String\u0026gt;? arguments]) { var result = executable; if (arguments != null) { result += \u0026#39; \u0026#39; + arguments.join(\u0026#39; \u0026#39;); // ✅ : `arguments`가 `null`이 아닌 것을 안다. } return result; } // or // Using null safety: String makeCommand(String executable, [List\u0026lt;String\u0026gt;? arguments]) { var result = executable; if (arguments == null) return result; return result + \u0026#39; \u0026#39; + arguments.join(\u0026#39; \u0026#39;); // ✅ : `arguments`가 `null`이 아닌 것을 안다. } Type promotion은 아래 두 가지 경우에만 사용할 수 있다.\nLocal variable Private final field (Dart 3.2) 위 두 가지 조건은 if condition 안에서 null이 아니었는데 control flow body 에서 다시 null이 되는 상황을 만들지 않는 조건이다.\n간혹 if문 안에서 null check를 했는데도 promotion이 안될 때가 있는데, 이 두 가지 조건을 만족하지 않는 변수 또는 field를 사용했을 것이다. 아래 코드는 _temperature가 final field가 아니기 때문에 promotion이 동작하지 않아 error가 발생한다.\n// Using null safety, incorrectly: class Coffee { String? _temperature; void checkTemp() { if (_temperature != null) { print(\u0026#39;Ready to serve \u0026#39; + _temperature + \u0026#39;!\u0026#39;); // ❌ : _temperature isn\u0026#39;t final } } } 변수 또는 field를 위 조건을 만족하도록 수정하기 어렵다면, local variable로 한 번 복사하는 pattern을 사용할 수 있다. 실제로 null check를 하는 대상이 local variable이 되어 promotion이 동작할 수 있다.\n// Using null safety, incorrectly: class Coffee { String? _temperature; void checkTemp() { var temperature = _temperature; if (_temperature != null) { print(\u0026#39;Ready to serve \u0026#39; + _temperature + \u0026#39;!\u0026#39;); // ✅ } } } Type promotion이 실패했을 때 수정하는 더 자세한 방법은 Fixing type promotion failures 문서를 참고해 보면 좋다.\nWorking with nullable types Nullable type이 null이 아닌 값을 가지고 있을 때, 이 non-nullable 값을 안전하게 사용하는 방법들을 정리한다. Null-aware operator와 Short-Circuit(단락) Null safety가 없을 때에도 null aware operator(?.)를 사용해서 nullable 변수에 저장된 non-nullable value를 안전하게 사용할 수 있었다. 이 연산자의 왼쪽 receiver가 null을 반환하면 오른쪽 구문 실행을 건너뛰고 전체 구문을 null로 평가하여 exception 없이 null을 반환한다. // With or without null safety: String notAString = null; print(notAString?.length); // null 그런데, 아래와 같이 ?. 연산자를 연달아 사용하는 경우 문제가 생긴다. 두 번째로 사용된 ?. 연산자가 어떤 구문을 위해 사용된 것인지 모호해진다. // Using null safety: void showGizmo(Thing? thing) { print(thing?.doohickey?.gizmo); } doohickey가 nullable field라면 ?. 연산자는 doohickey를 위해 사용된 것 doohickey가 non-nullable field라면 ?. 연산자는 thing?.doohickey를 위해 사용된 것 이 문제를 해결하기 위해서 receiver가 null로 평가되는 경우 구문의 나머지 chain에 대한 실행을 생략하는 short-circut 방식을 사용한다. 이 방법을 사용함으로써 두 번째 ?.는 doohickey가 nullable type이기 때문에 사용된 것임을 알 수 있다. Non-null assertion operator Nullable type이지만 null이 될 수 없는 변수에 대해 assertion을 통해 non-null value를 사용할 수 있다. as cast를 사용해서 nullable type이 갖고 있는 non-null value를 가져올 수 있다. String? value = \u0026#34;hello\u0026#34;; (value as String).toUpperCase(); // HELLO Nullable type은 underlying type과 Null type의 supertype 이다. 따라서, nullable type을 underlying type으로 downcasting 할 수 있다. ! 연산자는 왼쪽 구문을 underlying type으로 cast해 주는 축약 문법이다. 즉, as cast와 동일하게 동작한다. String? value = \u0026#34;hello\u0026#34;; value!.toUpperCase(); // HELLO 만약 value에 null이 저장되어 있다면 ! 연산자는 exception을 발생시키므로 사용에 주의한다. as cast는 exception을 발생시키지 않고 null을 반환한다. Conclusion Dart가 type system을 기반으로 null safety를 지원하는 방식을 깊이 이해할 수 있었다. 이 문서를 통해 flow analysis나 type promotion 등의 개념을 추가로 배울 수 있었다. 각각의 개념들이 null safety를 구현하는데 자주 언급되었기 떄문에 다시 개별적으로 더 공부해야 할 것 같다. 최근 진행한 면접에서 Dart의 type promotion이 가끔 동작하지 않는 이유에 대해 대답하지 못했는데, 이 문서를 통해 답을 찾을 수 있었다. Local variable과 private final field에 대해서만 type promotion이 동작한다는 것을 알게 되었으므로, type promotion이 동작하지 않는 상황에 더 잘 대처할 수 있을 것이다. ","permalink":"https://cskime.github.io/posts/dart-understanding-null-safety/","summary":"Overview 이 글은 Understanding null safety 문서의 내용을 바탕으로 Dart에서 null safety가 나온 배경 및 null safety의 동작 방식을 쉽게 이해하기 위해 작성하였다. 기본 문법적인 설명들을 제외하고 null safety의 원리를 이해하는데 필요하다고 생각되는 부분들만 정리했기 때문에 원문의 일부 내용이 누락되어 있고 설명하는 순서도 다르다. 빠르게 Dart null safety의 동작 방식에 대해 이해하는 것이 목적이라면 이 글을 이해하는 것으로 충분하겠지만, 더 자세한 설명이 필요하다면 원문을 정독하는 것을 권한다. Null safety가 나온 이유 Dart에서 null은 Null type으로 표현된다.","title":"[Dart] Understanding null safety"},{"content":"최근 본 면접에서 새로 알게 된 Exponential Back-Off 라는 개념과 Jitter를 사용한 개선 방법을 공부하고 정리한다. 그리고, Flutter 앱을 개발할 때 이 전략을 활용하기 위해 Dart code로 구현해 본다.\nRetry Strategy 어떤 system에서 다른 system을 call하는 상황에서 failure는 언제든지 발생할 수 있다. 앱을 개발할 때는 server 부하 또는 일시적인 network 오류 등에 의해 http 요청이 오랜 시간 동안 완료되지 않거나 실패하는 상황을 떠올릴 수 있다. 이러한 일시적인 문제 때문에 client에서 server로 보내는 data가 유실될 수 있는데, 이것을 막기 위해 여러 가지 방법으로 retry 전략을 세운다. Request timeout을 설정하여 일정 시간 동안 응답이 없으면 작업을 취소하고 동일한 request를 retry하는 것이 대표적인 예시이다. Exponential Back-Off 요청을 재시도할 때 가능한 또 다른 문제 중 하나는 연결이 정상화 되었을 때 server가 N개의 client로부터 동시다발적으로 요청을 수신하는 경우이다. Server가 한 번에 처리할 수 있는 양보다 훨씬 많은 수의 요청이 들어오면 server 과부하에 의해 data 유실 등의 문제가 여전히 발생할 수 있다. 이 문제를 해결하기 위해 요청을 분산시키는 방법으로 Exponential Back-Off(지수 백오프) 라는 방법을 사용한다. 말 그대로 backoff를 지수적으로 늘려가는 방법인데, retry 사이 시간 간격을 지수적으로 증가시키면서 더 많이 재시도 할 수록 더 나중에 요청을 보내도록 만든다. 이렇게 하면 server에 한 번에 들어오는 요청 수를 점진적으로 줄여나갈 수 있다. Exponential Back-Off with Jitter 하지만 이 방법도 문제가 있는데, 여전히 특정 시점에 server로 요청이 몰리게 된다. Retry 간격이 상수이기 때문에 근본적인 원인을 해결하긴 어렵다. 특정 시점에 몰리는 call 횟수를 가능 한 고르게 분산시켜야 하는데, 그 방법 중 하나가 Jitter를 추가하는 것이다. Jitter란 \u0026lsquo;지연 변이\u0026rsquo;라는 뜻으로, 지수 백오프에 randomness를 추가하여 0에서 지수 back-off 값 사이에 랜덤한 값을 delay로 사용한다. 이렇게 하면 지수 back-off만 적용했을 때 보다 요청이 고르게 분포될 수 있다. Implementation in Dart Implementation of Exponential Back-Off Exponential back-off는 Dart code로 구현해 보자. 아래는 exponential back-off delay를 계산하는 함수이다. Retry 횟수에 따라 delay가 2^n씩 증가한다.\nint sleep({ required int base, // delay 초깃값 required int attempts, // retry 시도 횟수 }) { final exp = min(attempts, 31); // prevent overflow final sleep = base * pow(2, exp); return sleep.toInt(); } 이 값을 request에 실패했을 때 다음 retry까지의 delay 시간으로 사용한다. 아래는 위 함수가 반환하는 값 만큼 delay를 주며 지정한 횟수 만큼 retry를 하는 함수이다.\nFuture\u0026lt;T\u0026gt; request\u0026lt;T\u0026gt;({ required int maxAttempts, required int baseDelay, required FutureOr\u0026lt;T\u0026gt; Function() taskBuilder, FutureOr\u0026lt;void\u0026gt; Function(int retryCount)? willRetry, }) async { var attempts = 0; while (true) { attempts += 1; try { return await taskBuilder(); } on Exception { // 최대 시도 횟수를 초과하면 retry 종료 if (attempts \u0026gt;= maxAttempts) { rethrow; } await willRetry?.call(); final delay = min( _maxTimeout, sleep(attempts: attempts, base: baseDelay), ); final duration = Duration(milliseconds: delay); await Future.delayed(duration); } } } Implementation of Exponential Back-Off with Jitter 아래는 exponential back-off를 구할 때 randomness를 추가하는 Dart code 이다.\nint sleep({ required int base, required int attempts, }) { final exp = min(attempts, 31); final sleep = base * pow(2, exp); return _random.nextInt(sleep.toInt()); // 0부터 sleep 사이의 random 값 } Packages Dart에서 exponential back-off를 통한 retry를 구현하는 package는 두 가지 정도 찾아볼 수 있었다. Randomization 구현 방식이 각각 다르기 때문에 상황에 맞게 선택해서 사용해도 좋을 것 같다. retry : Google에서 관리하는 package로, randomizationFactor 값을 설정하여 exponential back-off 값을 중심으로 -n% ~ +n% 사이의 값을 사용하도록 유연하게 설정할 수 있다는 장점이 있다. exponential_back_off : 개인 개발자가 관리하는 package로, maxRandomizationFactor 값을 설정하여 exponential back-off 값을 중심으로 0% ~ n% 사이의 값을 사용하도록 설정할 수 있다. Conclusion 실패가 없는 system을 만들 수는 없다. 실패했을 때 빠르게 잘 회복할 수 있는 system을 만드는 것이 중요하다. 지금까지 개발했던 앱에서는 retry 전략을 고려할 만큼 문제가 됐던 적이 없었지만, 사용자가 많아지고 server에 보내는 event들이 많아지면 이런 전략이 꼭 필요할 것 같다. 클라우드 서비스를 사용하는 경우 client에서 무분별하게 보내는 과도한 요청은 서비스의 안정성을 떨어뜨리고 비용 문제까지 갈 수도 있기 때문이다. Exponential backoff는 retry 전략을 위한 방법들 중 하나이지, 가장 좋은 방법이 아니다. Exponential backoff는 jitter를 추가하더라도 latency가 증가하는 등의 문제가 여전히 발생할 수 있다. 상황에 맞는 적절한 retry 전략을 구현해서 사용할 수 있어야 하겠다. 참고 Exponential Backoff And Jitter | AWS Architecture Blog Decoding Exponential Backoff: A Blueprint for Robust Communication | Medium retry | pub.dev exponential_back_off | pub.dev ","permalink":"https://cskime.github.io/posts/dart-retry-exp-backoff-jitter/","summary":"최근 본 면접에서 새로 알게 된 Exponential Back-Off 라는 개념과 Jitter를 사용한 개선 방법을 공부하고 정리한다. 그리고, Flutter 앱을 개발할 때 이 전략을 활용하기 위해 Dart code로 구현해 본다.\nRetry Strategy 어떤 system에서 다른 system을 call하는 상황에서 failure는 언제든지 발생할 수 있다. 앱을 개발할 때는 server 부하 또는 일시적인 network 오류 등에 의해 http 요청이 오랜 시간 동안 완료되지 않거나 실패하는 상황을 떠올릴 수 있다. 이러한 일시적인 문제 때문에 client에서 server로 보내는 data가 유실될 수 있는데, 이것을 막기 위해 여러 가지 방법으로 retry 전략을 세운다.","title":"Retry with Exponential Back-Off and Jitter"},{"content":"Overview DIP를 준수하는 class 설계를 위해 interface가 필요하다. 이 interface는 일반 class만 사용해도 쉽게 구현할 수 있다. 아래는 clean architecture에서 use case에서 repository 의존성을 분리하여 의존성 흐름이 adapter에서 business logic 계층으로 향하도록 역전시키는 구현 예시이다. Adaptor 계층에서 repository pattern을 사용하여 use case가 repository 의존성을 주입받는다.\nclass Repository { String fetchData() { throw Exception(\u0026#34;Not implemented\u0026#34;); }; } class RepositoryImpl extends Repository { @override String fetchData() { return storage.getData(); } } class UseCaseImpl extends UseCase { UseCaseImpl({required this.repository}); final Repository repository; String getData() { return repository.fetchData(); } } final repository = RepositoryImpl(); final useCase = UseCaseImpl(repository: repository); 이렇게 class만 사용해도 구현할 수 있지만 code가 의도와 다르게 사용될 여지가 있다. 가령, Repository는 의존성 역전을 위한 interface 역할만 해야 하므로 instance를 만들거나 스스로 구현 코드를 가지면 안된다.\n하지만, 위 코드에서 Repository는 일반 class이므로 interface를 생성할 수 있고 method는 반드시 구현부를 가져야 한다. Subclass에 구현을 위임하도록 강제하기 위해 Repository에 선언한 method에서 Exception을 발생시킬 수도 있겠지만, subclass가 fetchData를 override하지 않을 때 runtime에만 문제를 알 수 있으므로 위험한 코드다. 또, 모든 method에 같은 exception 코드를 추가해야 하므로 좋은 방법은 아니다.\nabstract modifier를 사용하는 방법 위에서 살펴본 문제들이 발생하지 않도록 compile-time에 제한하여 안정성을 높이는 것이 좋다. 그러려면 Repository는 아래 두가지 조건을 만족해야 한다.\nRepository는 instance를 생성할 수 없어야 한다. 구현체인 RepositoryImpl class는 fetchData method를 override하여 반드시 구현부를 추가해야 한다. 1번 조건을 만족시키기 위해 Repository를 abstract class로 만들 수 있다. 이렇게 하면 생성자로 instance를 생성할 수 없을 뿐만 아니라, Repository가 abstract method를 정의할 수 있으므로 exception을 발생시키지 않고도 compile time에 RepositoryImpl에 구현을 강제할 수 있다.\nabstract class Repository { String fetchData(); } class RepositoryImpl extends Repository { // Override 하지 않으면 compile error가 발생한다. @override String fetchData() { return storage.getData(); } } 하지만 이 방법에도 한계가 있는데, abstract modifier는 class에 단순히 abstract 특성을 부여하는 것이므로 여전히 Repository에 구현부를 가진 method를 선언할 수 있다는 것이다. abstract class에서 구현부를 가진 일반 method는 subclass에서 override하지 않아도 compile error가 발생하지 않는다.\nabstract class Repository { String fetchData() { return \u0026#34;Some data\u0026#34;; } } class RepositoryImpl extends Repository { // `fetchData`를 override 하지 않아도 compile error가 발생하지 않는다. } 이 정도는 subclass에 구현을 위임하려는 method를 반드시 abstract method로 선언하도록 개발자가 좀 더 신경쓰면 될 수도 있다. 하지만, 인간의 노력을 투입하지 않고 문제가 발생할 가능성을 제거하는 방법은 없을까?\ninterface modifier를 사용하는 방법 Subclass를 만들 때 abstract class를 implements로 구현하면 모든 method를 override하는 것이 compile-time에 강제되므로 문제를 해결할 수 있다. 하지만, abstract class는 extends로 확장시킬 수도 있기 때문에 실수로 문제가 발생할 가능성은 여전히 존재한다.\nextends를 사용한 확장을 제한하기 위해 abstract class대신 interface class로 만들면 어떨까? interface class는 implements로 구현하는 것만 허용되므로 fetchData method를 override하는 것이 강제되긴 하지만, abstract method를 가질 수 없으므로 method에 불필요한 구현부를 추가해야 한다는 문제가 다시 발생한다. 또, interface class는 instance를 생성할 수 있으므로 조건에 맞지 않는다.\ninterface class Repository { String fetchData() { throw Exception(\u0026#34;Not implemented\u0026#34;); } } class RepositoryImpl implements Repository { // `fetchData`를 override 하지 않으면 compile error가 발생한다. @override String fetchData() { return storage.getData(); } } // Instance를 생성할 수 있으므로 조건에 맞지 않는다. final repository = Repository(); abstract interface를 사용하는 방법 두 class modifier의 동작을 보면 \u0026ldquo;instance를 생성할 수 없고 method override를 compile-time에 강제해야 한다\u0026quot;는 조건은 각각 abstract와 interface modifier를 사용해서 강제할 수 있다. 따라서, 두 modifier를 합친 abstract interface를 사용하면 두 조건을 완벽하게 만족한다.\nabstract interface class Repository { String fetchData(); } final repository = Repository(); // ❌ : abstract가 instance 생성을 제한한다. class RepositoryImpl implements Repository { // interface가 확장(extends)을 제한하여 method를 override하도록 강제한다. @override String fetchData() { return storage.getData(); } } abstract interface가 위에서 언급한 두 가지 조건을 만족하지만, 사실 완벽하진 않다. Dart의 class modifier들은 확장과 구현 관계에 대해 같은 file 안에서는 제한을 두지 않기 때문이다. File 개수가 많아지는 것을 피하려고 interface와 구현체를 하나의 file에 작성한다면 2번 조건을 강제할 방법은 없다.\nConclusion abstract interface가 interface의 조건을 모두 만족하는 것 같지만, 같은 file 안에서는 기능을 제한하지 않으므로 한계가 있다. 따라서, 항상 interface와 구현체를 다른 file로 분리한다는 규칙이 없다면 abstract interface도 완벽하지 않다.\nabstract interface class라는 keyword 묶음은 코드를 꽤 장황하게 만든다. 어차피 사람이 규칙을 정해서 신경써야 한다면 abstract class로 instance 생성만 제한하고 method 선언과 override 규칙만 잘 지키면 되기 때문에 abstract modifier 하나만 사용하는 것이 코드를 간결하게 유지하는데 도움이 될 것 같다.\n한편으로, Dart의 class와 modifier들을 보고 있으면 Swift의 protocol이 그리워진다. protocol 자체가 instance를 생성할 수 있는 class가 아니고, protocol에 정의한 method들은 반드시 상속받은 class에서 구현을 추가해야 하기 때문이다. Swift를 사용하던 경험과 비교했을 때, Dart 언어는 class modifier가 과하게 파편화 되어 있다는 점과 확장 및 구현에 대한 제한이 다른 file에 대해서만 적용된다는 점이 아쉽다.\n","permalink":"https://cskime.github.io/posts/dart-di-interface/","summary":"Overview DIP를 준수하는 class 설계를 위해 interface가 필요하다. 이 interface는 일반 class만 사용해도 쉽게 구현할 수 있다. 아래는 clean architecture에서 use case에서 repository 의존성을 분리하여 의존성 흐름이 adapter에서 business logic 계층으로 향하도록 역전시키는 구현 예시이다. Adaptor 계층에서 repository pattern을 사용하여 use case가 repository 의존성을 주입받는다.\nclass Repository { String fetchData() { throw Exception(\u0026#34;Not implemented\u0026#34;); }; } class RepositoryImpl extends Repository { @override String fetchData() { return storage.getData(); } } class UseCaseImpl extends UseCase { UseCaseImpl({required this.","title":"[Dart] DI를 위한 interface 만들기"},{"content":"NumberFormat NumberFormat class는 intl package에서 제공하는 local-specific number formatting class \u0026ldquo;Locale-specific\u0026quot;이란, 문자열을 formatting 할 때 특정 text나 symbol을 locale에 맞게 변환해 주는 것 ICU formatting pattern을 사용해서 number format 지정 0 : a single digit # : a single digit, omitted if the value is zero . : decimal separator ¤(\\u00A4) : currency sign Examples NumberFormatter(\u0026#34;###.0#\u0026#34;).format(12.345); // 12.34 Currency formatting NumberFormatter는 currency formatting을 위한 named constructor를 제공함 NumberFormat.currency(locale,name,symbol,decimalDigits,customPattern) locale : ₩, $ 등 화폐 단위를 표기를 위한 locale name : 화폐 단위로 ISO 4217 code 사용 symbol : 화폐 단위로 custom sign 사용 (name을 덮어씀) decimalDigits : 소수점 아래 자릿수 customPattern : custom pattern 사용 Examples (en locale 기준) NumberFormat.currency().format(123456); // USD123,456.00 NumberFormat.currency(name: \u0026#34;N\u0026#34;).format(123456); // N123,456.00 NumberFormat.currency(symbol: \u0026#34;S\u0026#34;).format(123456); // S123,456.00 NumberFormat.currency(name: \u0026#34;N\u0026#34;, symbol: \u0026#34;S\u0026#34;).format(123456); // S123,456.00 NumberFormat.currency(locale: \u0026#34;ko\u0026#34;).format(123456); // KRW123,456.00 Currency formatting with simple and compact expression NumberFormat.currency()는 통화 단위로 ISO4217 code를 사용하며 길이가 긴 숫자도 그대로 표시 Simple expression은 통화 단위를 ISO4217 code에 해당하는 기호로 대체 Compact expression은 숫자를 천 단위는 K로, 백만 단위는 M로 축약 표기 (통화와 직접 관련은 없음. Number formatting의 기능) 관련 생성자들 NumberFormat.simpleCurrency NumberFormat.compactCurrency NumberFormat.compactSimpleCurrency Examples NumberFormat.simpleCurrency().format(123456); // $123,456 NumberFormat.compactCurrency().format(123456); // USD123K NumberFormat.compactSimpleCurrency().format(123456); // $123K 화폐 단위 오른쪽에 놓기 NumberFormatter로 formatting한 문자열에서는 화폐 단위가 항상 왼쪽에 나타난다. 10,000원 처럼 단위를 오른쪽에 적고 싶다면 customPattern을 사용할 수 있다. Examples NumberFormat.currency( symbol: \u0026#34;원\u0026#34;, customPattern: \u0026#34;###,###\\u00A4\u0026#34;, decimalDigits: 0, ).format(123456); // 123,456원 Formatting with name NumberFormat 객체를 만들 때 name을 사용하면 ISO4217 규격에 해당하는 통화 코드를 사용 규격에 맞지 않는 문자열을 사용하면 symbol처럼 동작 NumberFormat.simpleCurrency()에서는 name에 ISO4217 규격 code를 사용하면 해당 국가의 화폐 단위로 변환됨 NumberFormat.simpleCurrency().format(123456); // $123,456.00 NumberFormat.simpleCurrency(name: \u0026#34;KRW\u0026#34;).format(123456); // ₩123,456 NumberFormat.simpleCurrency(name: \u0026#34;JPY\u0026#34;).format(123456); // ￥123,456 NumberFormat.simpleCurrency(name: \u0026#34;OTHER\u0026#34;).format(123456); // OTHER123,456 NumberFormat.currency()에서는 name에 code를 사용해도 code를 그대로 출력하므로 symbol을 사용할 때와 같게 동작한다. 의미상 ISO4217 code를 사용하여 화폐 단위를 formatting할 때는 name을 사용하고, custom sign을 사용하고 싶다면 symbol을 사용하는게 좋은 것 같다. ","permalink":"https://cskime.github.io/posts/flutter-number-format-currency/","summary":"NumberFormat NumberFormat class는 intl package에서 제공하는 local-specific number formatting class \u0026ldquo;Locale-specific\u0026quot;이란, 문자열을 formatting 할 때 특정 text나 symbol을 locale에 맞게 변환해 주는 것 ICU formatting pattern을 사용해서 number format 지정 0 : a single digit # : a single digit, omitted if the value is zero . : decimal separator ¤(\\u00A4) : currency sign Examples NumberFormatter(\u0026#34;###.0#\u0026#34;).format(12.345); // 12.34 Currency formatting NumberFormatter는 currency formatting을 위한 named constructor를 제공함 NumberFormat.currency(locale,name,symbol,decimalDigits,customPattern) locale : ₩, $ 등 화폐 단위를 표기를 위한 locale name : 화폐 단위로 ISO 4217 code 사용 symbol : 화폐 단위로 custom sign 사용 (name을 덮어씀) decimalDigits : 소수점 아래 자릿수 customPattern : custom pattern 사용 Examples (en locale 기준) NumberFormat.","title":"[Flutter] NumberFormat을 사용해서 통화(currency) formatting 하기"},{"content":"Flutter는 두 가지 방법으로 gradient를 적용할 수 있다.\nBoxDecoration 사용 ShaderMask 사용 BoxDecoration BoxDecoration의 gradient 속성에 gradient를 적용한다. Box widget을 gradient로 채울 때 사용한다. Example Container( width: 100, height: 100, decoration: const BoxDecoration( gradient: LinearGradient( colors: [Colors.red, Colors.blue], ), ), ), ShaderMask ShaderMask를 사용해서 특정 widget에 shader를 입힐 수 있다.\nShaderMask의 shaderCallback에서 shader 객체를 반환하면 child에 전달한 widget에서 white color인 element에 shader를 입힐 수 있다.\nshaderCallback 함수는 LinearGradient 등 gradient 객체의 createShader(rect) method를 사용해서 shader를 반환할 수 있다.\nExample\nShader gradientShaderCallback(Rect rect) =\u0026gt; const LinearGradient( colors: [Colors.red, Colors.blue], ).createShader(rect); ShaderMask( shaderCallback: gradientShaderCallback, child: const Text( \u0026#34;Hello\u0026#34;, style: TextStyle(color: Colors.white), ), ), ShaderMask( shaderCallback: gradientShaderCallback, child: const Icon( Icons.home, color: Colors.white, ), ), Shader가 white 색상에만 적용되는 이유 ShaderMask의 속성 중 blendMode는 기본값이 BlendMode.modulate BlendMode.modulate는 source와 destination의 color를 multiply함 (docs) 이 blend mode는 white에 대해서는 원래 색상을 유지하고 black으로 갈 수록 원래 색상에서 더 어두워진다. 의도한 gradient 색상이 나타나려면 gradient를 입힐 element가 white 색상이 되어야 한다. ","permalink":"https://cskime.github.io/posts/flutter-gradient/","summary":"Flutter는 두 가지 방법으로 gradient를 적용할 수 있다.\nBoxDecoration 사용 ShaderMask 사용 BoxDecoration BoxDecoration의 gradient 속성에 gradient를 적용한다. Box widget을 gradient로 채울 때 사용한다. Example Container( width: 100, height: 100, decoration: const BoxDecoration( gradient: LinearGradient( colors: [Colors.red, Colors.blue], ), ), ), ShaderMask ShaderMask를 사용해서 특정 widget에 shader를 입힐 수 있다.\nShaderMask의 shaderCallback에서 shader 객체를 반환하면 child에 전달한 widget에서 white color인 element에 shader를 입힐 수 있다.\nshaderCallback 함수는 LinearGradient 등 gradient 객체의 createShader(rect) method를 사용해서 shader를 반환할 수 있다.","title":"[Flutter] Gradient를 적용하는 두 가지 방법"},{"content":"Scaffold를 사용하는 경우 Modal bottom sheet 안에서 Scaffold의 AppBar를 활용하는 경우 ModalBottomSheetRoute의 border radius와 Clip.hardEdge를 설정한다. showModalBottomSheet()를 사용하는 경우: showModalBottomSheet( context: context, shape: const RoundedRectangleBorder( borderRadius: BorderRadius.vertical( top: Radius.circular(24), ), ), clipBehavior: Clip.hardEdge, builder: (context) =\u0026gt; Scaffold( appBar: AppBar(...), body: Container(...), ), ) Navigator.push에 ModalBottomSheetRoute를 직접 사용하는 경우: final route = MaterialPageRoute( shape: const RoundedRectangleBorder( borderRadius: BorderRadius.vertical( top: Radius.circular(24), ), ), clipBehavior: Clip.hardEdge, builder: (context) =\u0026gt; Scaffold( appBar: AppBar(...), body: Container(...), ), ); Navigator.of(context).push(route); 일반 widget을 사용하는 경우 Scaffold 없이 Container 같은 일반 widget을 사용할 때는 Container의 decoration에서 border를 설정할 수 있다. 먼저 ModalBottomSheetRoute의 backgroundColor를 Colors.transparent로 제거한다. showModalBottomSheet( context: context, backgroundColor: Colors.transparent, builder: (context) =\u0026gt; const Container(...), ) 이후 builder에서 반환하는 Container의 decoration에서 border radius와 Clip.hardEdge를 설정한다. Container( decoration: BoxDecoration( borderRadius: BorderRadius.vertical(top: Radius.circular(24)), ), clipBehavior: Clip.hardEdge, child: SomeWidget(), ) Scaffold를 사용하지만 radius를 widget 안에서 설정하고 싶은 경우 showModalBottomSheet( context: context, // 1. 전체 배경은 투명하게 backgroundColor: Colors.transparent, // 2. Container로 border radius 설정 builder: (context) =\u0026gt; const Container( // 3. 필요하다면 content 영역 높이 고정 가능 height: MediaQuery.sizeOf(context) * 0.8, decoration: BoxDecoration( borderRadius: BorderRadius.vertical( top: Radius.circular(24), ), ), clipBehavior: Clip.hardEdge, // 4. Scaffold의 background color와 appBar, body 적용 child: Scaffold( appBar: AppBar(...), body: SomeWidget(...), ), ), ); Border radius와 Clip.hardEdge를 설정한 Container의 child로 Scaffold를 사용하면 비슷한 효과를 줄 수 있다. Scaffold를 감싸는 Container를 활용해서 modal bottom sheet를 특정 높이로 고정시키는 등 customizing에 용이하다. ","permalink":"https://cskime.github.io/posts/modalbottomsheet-border-radius/","summary":"Scaffold를 사용하는 경우 Modal bottom sheet 안에서 Scaffold의 AppBar를 활용하는 경우 ModalBottomSheetRoute의 border radius와 Clip.hardEdge를 설정한다. showModalBottomSheet()를 사용하는 경우: showModalBottomSheet( context: context, shape: const RoundedRectangleBorder( borderRadius: BorderRadius.vertical( top: Radius.circular(24), ), ), clipBehavior: Clip.hardEdge, builder: (context) =\u0026gt; Scaffold( appBar: AppBar(...), body: Container(...), ), ) Navigator.push에 ModalBottomSheetRoute를 직접 사용하는 경우: final route = MaterialPageRoute( shape: const RoundedRectangleBorder( borderRadius: BorderRadius.vertical( top: Radius.circular(24), ), ), clipBehavior: Clip.hardEdge, builder: (context) =\u0026gt; Scaffold( appBar: AppBar(...), body: Container(.","title":"[Flutter] Modal bottom sheet 상단에 border radius 주기"},{"content":" Flutter app에서 TextField 등의 widget을 탭하면 해당 widget의 FocusNode가 활성화되면서 가상 키보드가 나타남 가상 키보드를 닫으려면 해당 widget의 FocusNode를 비활성화(unfocus) 시켜야 한다. FocusScope 사용 FocusScope는 FocusNode를 하나의 group으로 묶어서 관리할 때 사용하는 widget으로, Route가 push될 때 자동으로 생성되어 widget tree에 추가됨 FocusScope.of(context) method가 반환하는 FocusScopeNode는 FocusNode의 subclass로, FocusScope group 안에서 focus를 제어하는 객체 FocusScopeNode의 unfocus()를 호출해서 현재 focusing된 widget(e.g. TextField)을 unfocus 시킨다. FocusScope.of(context).unfocus(); 또는, requestFocus()에 새로운 FocusNode를 전달하여 이전 focus를 해제시킨다. FocusScope.of(context).requestFocus(FocusNode()); FocusManager 사용 FocusManager는 app의 전체 focus tree를 관리하는 전역 객체로 모든 FocusNode 및 FocusScope를 관리함 FocusManager.instance.primaryFocus로 현재 focus가 활성화된 FocusNode를 반환함 이 FocusNode의 unfocus()를 호출해서 unfocus 시킨다. FocusManager.instance.currentFocus?.unfocus(); FocusScope와 FocusManager 중 어떤 것을 사용할까? FocusScope와 FocusManager는 각자 수행하는 역할이 다르다. FocusScope는 FocusNode를 group으로 묶어서 관리할 때 사용한다. FocusManager는 app 전역에서 focus를 제어하거나 focus 흐름을 추적할 때 사용한다. App에서 화면 빈 곳 등을 터치해서 가상 키보드를 닫으려고 할 때는 어떤 것을 사용해도 크게 문제되지 않는다. 단, FocusScope.of(context) code에 의해 현재 widget에서 focus가 변경될 때 마다 widget을 rebuild 하여 성능 문제가 발생할 여지가 있다. FocusManager는 전역 객체이므로, 일반적인 상황에서는 현재 widget으로부터 가장 가까운 local 객체인 FocusScope를 사용하고 불필요한 widget rebuild에 의한 성능 문제가 발생한다면 FocusManager를 사용하는게 좋을 것 같다. Reference What is the difference between FocusScope.of(context).unfocus() and FocusManager.instance.primaryFocus?.unfocus() in the flutter? | Stack Overflow How to unfocus TextField that has custom FocusNode? | Stack Overflow ","permalink":"https://cskime.github.io/posts/flutter-unfocus/","summary":"Flutter app에서 TextField 등의 widget을 탭하면 해당 widget의 FocusNode가 활성화되면서 가상 키보드가 나타남 가상 키보드를 닫으려면 해당 widget의 FocusNode를 비활성화(unfocus) 시켜야 한다. FocusScope 사용 FocusScope는 FocusNode를 하나의 group으로 묶어서 관리할 때 사용하는 widget으로, Route가 push될 때 자동으로 생성되어 widget tree에 추가됨 FocusScope.of(context) method가 반환하는 FocusScopeNode는 FocusNode의 subclass로, FocusScope group 안에서 focus를 제어하는 객체 FocusScopeNode의 unfocus()를 호출해서 현재 focusing된 widget(e.g. TextField)을 unfocus 시킨다. FocusScope.of(context).unfocus(); 또는, requestFocus()에 새로운 FocusNode를 전달하여 이전 focus를 해제시킨다.","title":"[Flutter] 화면 빈 곳을 tap해서 가상 키보드 닫기"},{"content":" Iterable collections Dart 문서 읽기\nCollection과 Iterable Collection : element의 집합을 표현하는 객체 (e.g. List, Set, Map)\nIterable : element에 순차적으로 접근할 수 있는 collection의 한 종류\nIterable abstract class를 상속받은 List, Set 등을 통해 Iterable 객체 생성\nMap은 key를 사용해서 value를 얻는 방식으로 Iterable이 아님. 단, entries나 values 속성을 통해 key 또는 value group을 Iterable 객체로 읽을 수 있음\nIterable과 List는 element에 접근하는 방법에 차이가 있음\nList는 [index] operator를 사용하지만, Iterable은 elementAt(index) method를 사용해서 특정 index의 element에 접근\nIterable\u0026lt;int\u0026gt; iterable = [1, 2, 3]; print(iterable.elementAt(1)); // 2 List\u0026lt;int\u0026gt; list = [1, 2, 3]; print(list[1]); // 2 elementAt()은 index까지 다른 element들을 무시함 (step through)\nReading elements for-in loop : Iterable을 순회하며 element 읽기 const iterable = [\u0026#34;Salad\u0026#34;, \u0026#34;popcorn\u0026#34;]; for (final element in iterable) { print(element); } first and last : Iterable의 첫 번째 또는 마지막 element 읽기 Iterable\u0026lt;String\u0026gt; iterable = const [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Toast\u0026#34;]; iterable.first; // Salad iterable.last; // Toast Empty Iterable에서 사용하면 StateError 발생 firstWhere(predicate) : 특정 조건을 만족하는 첫 번째 element 읽기 const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Toast\u0026#34;, \u0026#34;Lasagne\u0026#34;]; final element = iterable.firstWhere( (element) =\u0026gt; element.length \u0026gt; 5, orElse: () =\u0026gt; \u0026#34;None!\u0026#34;, ); print(element); // Popcorn predicate 함수에서 조건을 검사하여 true를 반환하는 첫 번째 element 반환 조건에 만족하는 element를 찾지 못하면, StateError 발생 orElse 함수를 전달하면 이 함수가 반환하는 값을 반환 singleWhere(predicate) : 특정 조건을 단 한번만 만족하는 element 읽기 const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Toast\u0026#34;, \u0026#34;Lasagne\u0026#34;]; final element = items.singleWhere( (element) =\u0026gt; element.startsWith(\u0026#34;M\u0026#34;) \u0026amp;\u0026amp; element.contains(\u0026#34;a\u0026#34;), ); print(element); // Milk firstWhere()는 조건에 맞는 element를 찾으면 종료 singleWhere()는 Iterable의 모든 element를 순회하므로 infinite 또는 element가 아주 많은 Iterable에서 사용하면 StateError가 발생할 수 있음 Checking conditions every(predicate) : 모든 element가 predicate 조건을 만족할 때 true 반환 final isValid = items.every((item) =\u0026gt; item.length \u0026gt;= 5); any() : predicate 조건을 만족하는 element가 최소 1개 이상일 때 true 반환 const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Toast\u0026#34;]; final any = items.any((item) =\u0026gt; item.contains(\u0026#34;a\u0026#34;)); // true (Salad or Toast) final every = items.every((item) =\u0026gt; item.length \u0026gt;= 5); // any()는 조건을 만족하는 element가 1개라도 있으면 true를 반환 any()를 조건을 만족하는 element가 없다는 것을 검증할 때도 사용 가능 (false를 반환하는 경우) Filtering elements where() : 특정 조건을 만족하는 모든 element를 찾아서 새 Iterable(WhereIterable)로 만들어 반환 final evenNumbers = numbers.where((number) =\u0026gt; number.isEven); firstWhere()나 singleWhere()는 조건을 만족하는 element 1개를 찾는다는 차이가 있다. 조건에 맞는 element가 없다면 empty Iterable 반환 (firstWhere()와 달리 StateError를 발생시키지 않음) takeWhile(predicate) : predicate에서 false를 반환하기 이전 element들을 모아서 새 Iterable로 반환 const numbers = [1, 3, -2, 0, 4, 5]; final numbersUntilZero = numbers.takeWhile((number) =\u0026gt; number != 0); print(numbersUntilZero); // [1, 3, -2] skipWhile() : predicate에서 false를 반환한 이후 element들을 모아서 새 Iterable로 반환 const numbers = [1, 3, -2, 0, 4, 5]; final numbersUntilZero = numbers.skipWhile((number) =\u0026gt; number != 0); print(numbersUntilZero); // [0, 4, 5] predicate에서 false를 반환하는 element를 찾으면 이후 element에 대해서는 조건을 검사하지 않음 Mapping elements map() : Iterable의 각 element들을 새로운 값으로 교체 Iterable\u0026lt;int\u0026gt; output = numbers.map((number) =\u0026gt; number * 10); Other APIs 문서에서 소개한 함수 외에 Iterable 객체에서 사용할 수 있는 유용한 함수들\nfold() const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Toast\u0026#34;, \u0026#34;Lasagne\u0026#34;]; final count = items.fold(0, (previous, element) =\u0026gt; previous + element.length); print(count); // 28 = 5 + 7 + 4 + 5 + 7 collection의 element들을 initialValue와 연산하여 하나의 값으로 합침 다른 언어의 reduce 함수 reduce() const items = [1, 2, 3]; final sum = items.reduce((value, element) =\u0026gt; value + element); print(sum); // 6 fold와 같은 역할이지만, initialValue 없이 collection의 element들을 가지고 연산 다른 언어의 reduce와 달리 결과 type이 원본 collection type으로 고정되어 있음 Collection이 비어있다면 IterableElementError 발생 forEach() const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Toast\u0026#34;]; items.forEach(print); // Salad, Popcorn, Toast 각 element들에 대해 함수 실행 join() const numbers = [1, 2, 3]; final result = numbers.join(\u0026#34;-\u0026#34;); print(result); // 1-2-3 Element를 String type으로 변환한 뒤 separator로 연결(concatenate) contains() const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Toast\u0026#34;]; items.contains(\u0026#34;Toast\u0026#34;); // true items.contains(\u0026#34;Milk\u0026#34;); // false Iterable에 element가 들어 있는지 판단 Dart의 모든 값은 객체이므로 Object type parameter로 전달 가능 take(count) const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Toast\u0026#34;, \u0026#34;Lasagne\u0026#34;]; final result = items.take(3); print(result); // [Salad, Popcorn, Milk] Iterable의 element들 중 처음 count개의 element를 모아서 lazy iterable 생성 내부적으로 iterator가 count개의 element를 읽은 후에야 iterable을 생성 skip(count) const items = [\u0026#34;Salad\u0026#34;, \u0026#34;Popcorn\u0026#34;, \u0026#34;Milk\u0026#34;, \u0026#34;Toast\u0026#34;, \u0026#34;Lasagne\u0026#34;]; final result = items.skip(3); print(result); // [Toast, Lasagne] Iterable의 element들 중 처음 count개의 element를 제외한 나머지 element들을 모아서 iterable 생성 ","permalink":"https://cskime.github.io/posts/iterable-collections/","summary":"Iterable collections Dart 문서 읽기\nCollection과 Iterable Collection : element의 집합을 표현하는 객체 (e.g. List, Set, Map)\nIterable : element에 순차적으로 접근할 수 있는 collection의 한 종류\nIterable abstract class를 상속받은 List, Set 등을 통해 Iterable 객체 생성\nMap은 key를 사용해서 value를 얻는 방식으로 Iterable이 아님. 단, entries나 values 속성을 통해 key 또는 value group을 Iterable 객체로 읽을 수 있음\nIterable과 List는 element에 접근하는 방법에 차이가 있음\nList는 [index] operator를 사용하지만, Iterable은 elementAt(index) method를 사용해서 특정 index의 element에 접근","title":"[Dart] Iterable collections"},{"content":" 이 글에서는 vertical direction scroll을 가정한다.\nOverview Scrollable widget은 전체 content 높이가 화면 높이보다 작다면 scroll이 활성화되지 않고 content들이 상단 정렬된다. 아래는 SingleChildScrollView에 Column을 사용해서 content widget과 footer widget을 배치하는 예시이다.\nCode Demo Footer widget을 화면 하단에 배치하기 위해 content와 footer widget 사이에 Spacer, Expanded와 같은 flexible widget을 사용하면 unbounded height error가 발생한다. Scrollable widget은 child widget에게 unbounded height constraint를 제안하는데, Spacer나 Expanded도 unbounded size를 갖기 때문이다.\nFixed Footer 구현 위 error를 해결하려면 아래와 같은 조건이 필요하다.\nScrollable child widget의 최소 height는 content가 표시될 수 있는 화면 크기여야 한다. 최소 크기가 고정되어야 unbounded height error를 수정할 수 있다. 고정되는 크기가 화면 크기와 비슷하게 커져야 가운데 Spacer를 두고 footer widget이 하단에 고정될 수 있다. Scrollable child widget의 최대 height은 infinity 이어야 한다. 최대 무한대로 크기가 늘어날 수 있어야 화면 크기를 벗어나는 content에 대해 scroll을 활성화 시킬 수 있다. 이 조건을 만족시키기 위해 아래와 같은 widget들을 활용할 수 있다.\nLayoutBuilder Scrollable widget이 content를 보여줄 수 있는 최대 크기를 얻기 위해 사용한다. Scrollable widget을 LayoutBuilder로 감싸고, builder 함수로 전달되는 constraints를 scrollable widget의 child widget에서 사용한다. ConstrainedBox Parent widget으로부터 받은 constraint를 무시하고 child에 새 constraint를 부여한다. Scrollable widget은 parent로부터 0.0\u0026lt;=h\u0026lt;={screenHeight}의 height constraint를 받는데, 조건을 만족하기 위해 필요한 constraint는 {screenHeight}\u0026lt;=h\u0026lt;=infinity이므로 constraint를 바꿔주어야 한다. IntrinsicHeight 새 constraint는 최대 높이가 infinity이므로 scrollable widget의 child widget height을 고정시키지 않으면 Spacer를 사용할 수 없다. IntrinsicHeight은 child widget의 height을 intrinsic height으로 고정시키므로, Spacer를 사용했을 때 ConstrainedBox로 새로 설정한 constraint의 최소 높이로 고정될 수 있다. 세 가지 widget을 아래와 같이 사용하여 footer를 하단에 고정시킬 수 있다.\nConstrainedBox에서 새로 설정한 constraint는 최대 크기가 infinity이므로 scrollable widget의 child widget의 높이가 screen보다 커질 수도 있다. 이 때, 일반 scrollable widget처럼 scroll이 가능하다.\nContent가 Screen 높이보다 작을 때 Content가 Screen 높이보다 클 때 Custom Widget으로 만들기 Fixed footer를 만드는 boilerplate code를 custom widget으로 추출해서 재사용할 수 있다.\nCustom Widget Example ","permalink":"https://cskime.github.io/posts/fixed-footer-scrollview/","summary":"이 글에서는 vertical direction scroll을 가정한다.\nOverview Scrollable widget은 전체 content 높이가 화면 높이보다 작다면 scroll이 활성화되지 않고 content들이 상단 정렬된다. 아래는 SingleChildScrollView에 Column을 사용해서 content widget과 footer widget을 배치하는 예시이다.\nCode Demo Footer widget을 화면 하단에 배치하기 위해 content와 footer widget 사이에 Spacer, Expanded와 같은 flexible widget을 사용하면 unbounded height error가 발생한다. Scrollable widget은 child widget에게 unbounded height constraint를 제안하는데, Spacer나 Expanded도 unbounded size를 갖기 때문이다.\nFixed Footer 구현 위 error를 해결하려면 아래와 같은 조건이 필요하다.","title":"[Flutter] Bottom fixed footer를 갖는 scrollable widget 만들기"},{"content":"Overview 광복절을 기념해서 Flutter로 태극기를 그려봤다. (Repository)\n태극기 도면을 참고했고, CustomPaint를 사용했다.\n깃면 그리기 태극기 깃면의 가로:세로 비율은 3:2이므로, AspectRatio로 3:2 비율의 widget을 만든다. DecoratedBox를 사용해서 border를 그려준다. AspectRatio의 child에 LayoutBuilder를 사용해서 CustomPaint의 size를 깃면 size로 설정한다. CustomPaint는 이 수치를 기반으로 태극 문양과 괘의 layout을 계산한다. 태극 문양 그리기 태극 문양은 아래 두 단계에 걸쳐 그릴 수 있다.\n빨간색과 파란색 반으로 나뉜 원을 그린다. 반지름을 지름으로 하는 빨간색, 파란색 원을 왼쪽, 오른쪽에 덮어서 그린다. 이 때, 빨간색과 파란θ색 반원은 태극기의 왼쪽 위 모서리와 오른쪽 아래 모서리로 그어지는 대각선으로 나뉜다. 따라서, drawArc로 반원을 그릴 때 시작 각도(startAngle)는 0과 pi에서 이 대각선의 내각을 더한 위치가 된다. 태극기의 절반인 직각 삼각형에서 밑변과 높이를 알고 있으므로, 내각은 아래와 같이 계산할 수 있다.\n$\\theta = \\arctan(\\frac{b}{a})$\n위 공식에 따라 atan() 함수를 사용해서 내각을 구하고, Canvas.drawArc에서 startAngle에 이 내각을 더해주면 아래와 같이 그려진다.\nclass TaegukgiPainter extends CustomPainter { @override void paint(Canvas canvas, Size size) { final angle = atan(size.height / size.width); ... canvas.drawArc(rect, angle, pi, false, bluePaint); canvas.drawArc(rect, pi + angle, pi, false, redPaint); } } 다음으로, 대각선을 축으로 하고 그려진 원의 반지름을 지름으로 하는 빨간색, 파란색 반원을 그려준다.\n각 원의 색상이 기존 색상을 덮어쓰면서 아래와 같이 태극 모양으로 보이게 된다.\n괘 그리기 괘는 태극기를 가로지르는 대각선에 수직 방향으로 그려진다. 위에서 계산한 대각선 사잇각과 직각 삼각형의 성질을 이용해서 아래와 같이 괘의 중심점과 양 끝점을 계산할 수 있다.\n괘의 각 line의 center 좌표를 계산한 뒤, center에서 좌우로 떨어져 있는 두 point를 계산하여 drawLine으로 괘를 그려준다. 괘의 line 길이, 두께, line 간격 등을 모두 알고 있으므로 for문을 이용해서 3줄의 line을 같은 방법으로 그려준다. 아래는 곤괘를 그리는 예시이다.\n괘를 그리는 전체 코드는 여기에서 확인할 수 있다.\n후기 광복절을 맞아 태극기를 직접 그려보면서 태극기가 어떻게 구성되어 있고 어떤 수치로 그려지는지 자세하게 알아볼 수 있어서 흥미로웠다. 특히, 태극기에서 각 괘를 부르는 호칭과 각 괘의 위치를 정확하게 알 수 있는 좋은 기회였다. CustomPaint를 사용해서 비정형 UI를 그리는 것에 더 익숙해 질 수 있었다. ","permalink":"https://cskime.github.io/posts/flutter-taegeukgi/","summary":"Overview 광복절을 기념해서 Flutter로 태극기를 그려봤다. (Repository)\n태극기 도면을 참고했고, CustomPaint를 사용했다.\n깃면 그리기 태극기 깃면의 가로:세로 비율은 3:2이므로, AspectRatio로 3:2 비율의 widget을 만든다. DecoratedBox를 사용해서 border를 그려준다. AspectRatio의 child에 LayoutBuilder를 사용해서 CustomPaint의 size를 깃면 size로 설정한다. CustomPaint는 이 수치를 기반으로 태극 문양과 괘의 layout을 계산한다. 태극 문양 그리기 태극 문양은 아래 두 단계에 걸쳐 그릴 수 있다.\n빨간색과 파란색 반으로 나뉜 원을 그린다. 반지름을 지름으로 하는 빨간색, 파란색 원을 왼쪽, 오른쪽에 덮어서 그린다.","title":"[Flutter] 🇰🇷 광복절 기념 태극기 그리기 🇰🇷"},{"content":"Summary 셋 모두 Iterable object를 동일한 element를 가진 새 List로 copy할 때 사용할 수 있다. toList()는 List.of의 short-hand method로 서로 같다. List.from은 original Iterable의 element들을 runtime에 result type으로 casting하고, casting에 실패하면 runtime error를 발생시킨다. List.of는 original Iterable의 element들이 result type과 같거나 하위 type인지 compile-time에 check하고, type이 호환되지 않으면 compile-time error를 발생시킨다. List.from은 original Iterable을 down casting할 때 사용할 수 있고, List.of는 up casting할 때 사용할 수 있다. Copy 할 때 original type을 지켜야 한다면 toList() 또는 List.of를 사용하고, type을 변경할 때만 List.from을 사용하자. List.from(elements) elements에 Iterable type을 전달하여 새로운 List 생성 Definition external factory List.from(Iterable elements, {bool growable = true}); elements의 item type을 고려하지 않기 때문에 새로 생성하는 list의 item type을 지정하지 않으면 List\u0026lt;dynamic\u0026gt;으로 생성됨 final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final dynamicList = List.from(nums); print(dynamicList.runtimeType); // List\u0026lt;dynamic\u0026gt; 새로 생성하는 list의 item type을 지정하면 elements의 item type이 type casting됨 final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final numList = List\u0026lt;num\u0026gt;.from(nums); print(numList.runtimeType); // List\u0026lt;num\u0026gt; 새로 생성하는 list의 item type이 runtime에 결정된다. 즉, compile-time에 type check를 하지 않는다. String type인 \u0026quot;3\u0026quot;을 int로 직접 type casting 할 수 없으므로 type error가 발생한다. final nums = [1, 2, \u0026#34;3\u0026#34;]; // List\u0026lt;Object\u0026gt; // TypeError: \u0026#34;3\u0026#34;: type \u0026#39;String\u0026#39; is not a subtype of type \u0026#39;int\u0026#39; final intList = List\u0026lt;int\u0026gt;.from(nums); double type인 3.0은 int로 casting 가능하므로 runtime error가 발생하지 않지만, 여전히 compile time에는 알 수 없다. final nums = [1, 2, 3.0]; // List\u0026lt;num\u0026gt; final intList = List\u0026lt;int\u0026gt;.from(nums); print(intList.runtimeType); // List\u0026lt;int\u0026gt; List.of(elements) elements에 Iterable type을 전달하여 새로운 List 생성 =\u0026gt; 역할은 List.from과 같음 Definition external factory List.of(Iterable\u0026lt;E\u0026gt; elements, {bool growable = true}); elements의 item type과 새로 생성하는 list의 item type이 같으므로, 생성하는 list의 item type을 지정하지 않으면 elements의 item type을 따라간다. final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final = List.of(nums); print(intList.runtimeType); // List\u0026lt;int\u0026gt; 새로 생성하는 list의 item type을 지정하면 elements의 item type도 같은 type이어야 한다. elements에 다른 item type을 가진 list를 전달하면 compile error가 발생한다. final nums = \u0026lt;num\u0026gt;[1, 2, 3]; // List\u0026lt;int\u0026gt; // Error: The argument type \u0026#39;List\u0026lt;num\u0026gt;\u0026#39; can\u0026#39;t be assigned to the parameter type \u0026#39;Iterable\u0026lt;int\u0026gt;\u0026#39;. final intList = List\u0026lt;int\u0026gt;.of(nums); 단, 새로 생성하는 list의 item type이 elements item type의 상위 type이라면 up casting 될 수 있다. final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final = List\u0026lt;num\u0026gt;.of(nums); print(intList.runtimeType); // List\u0026lt;num\u0026gt; .toList() List\u0026lt;E\u0026gt; toList({bool growable = true}) =\u0026gt; List\u0026lt;E\u0026gt;.of(this, growable: growable); List.of의 shortcut method List.of로 감싸는 대신 toList()를 사용하는게 더 간단하다. Don\u0026rsquo;t use List.from unless you intent to change the type of the result Effective Dart 문서에서는 result type을 의도적으로 바꾸고 싶을 때만 List.from을 사용하도록 제한한다. 이외에 original Iterable과 result List의 element type이 같은 경우에는 List.of 또는 toList()를 사용한다. List.of도 공통된 상위 type으로 up casting이 가능하지만, original type을 유지하지 않는 경우에는 모두 List.from을 사용하는게 일관성을 지킬 수 있을 것 같다. ","permalink":"https://cskime.github.io/posts/list-of-vs-list-from/","summary":"Summary 셋 모두 Iterable object를 동일한 element를 가진 새 List로 copy할 때 사용할 수 있다. toList()는 List.of의 short-hand method로 서로 같다. List.from은 original Iterable의 element들을 runtime에 result type으로 casting하고, casting에 실패하면 runtime error를 발생시킨다. List.of는 original Iterable의 element들이 result type과 같거나 하위 type인지 compile-time에 check하고, type이 호환되지 않으면 compile-time error를 발생시킨다. List.from은 original Iterable을 down casting할 때 사용할 수 있고, List.of는 up casting할 때 사용할 수 있다. Copy 할 때 original type을 지켜야 한다면 toList() 또는 List.","title":"[Dart] List.from, List.of, toList() 비교"},{"content":"나는 iOS 개발자로 일하다가 지난 해 퇴사 후 안식년을 갖고 있다. 쉬는 동안 개발자라는 직업에 대한 고민을 많이 하고 있는데, 나는 어떤 개발자가 되고 싶은지 방향성을 잃어가고 있다는 생각이 들었기 때문이다. 개발하는 것 자체는 즐거운 일이지만 개발자라는 직업이 정말 나와 맞는지, 개발자를 오래 할 수 있을지 확신이 들지 않았다. 그래서, 쉬는 동안 다양한 개발 분야를 넓게 경험해보면서 생각을 정리해보고 있다.\nFlutter 10주 스터디 전에도 노마드코더에서 웹 기초 10주 스터디에 참여했던 적이 있다. iOS 개발을 주로 했었기 때문에, 쉬는 동안에는 아예 다른 분야를 경험해보고 싶어서 웹 개발을 선택했다. 웹 개발은 배울 수 있는 곳이 많아서 어디서 강의를 들어볼지 정하기가 어려웠는데, 노마드코더의 강의 스타일과 챌린지 시스템이 마음에 들어서 노마드 코더를 선택했다. 웹 풀스택 개발을 빠르게 경험해볼 수 있다는 것과 어딘가 소속되어 공부할 수 있다는 점도 당시에 스터디에 참여했던 이유 중 하나였다.\n웹 기초 10주 스터디를 졸업한 뒤 노마드코더의 10주 스터디 시스템은 빠르게 지식을 흡수하고 다양한 경험을 해볼 수 있는 가장 좋은 선택지라는 생각이 들었다. 그래서 Flutter를 배워보기로 결정했을 때에도 망섬일 없이 노마드코더의 Flutter 스터디를 선택할 수 있었다. 스터디를 하는 동안 만든 결과물이 약 20개 정도 된다. 꾸준히 강의를 따라가며 만들었던 결과물들을 보니 두 달 반을 헛되게 보낸 건 아니라는 생각이 든다.\nNomadcoders Flutter 10주 스터디 Flutter 10주 스터디 챌린지 결과물 졸업과제 - Apple Music Search 좋았던 점 함께 공부하는 사람들이 있어서 외롭지 않았다. 특히, 일일 스프린트에 올라오는 todo와 주간 회고는 슬럼프가 찾아왔을 때 목표를 잃지 않고 매일 조금씩 꾸준히 공부해 나가는 데 많은 도움이 되었다. 강의를 듣고 챌린지 과제를 하면서 궁금했던 것이나 어려웠던 것을 TA 분들께 바로바로 물어보고 답변을 받을 수 있었다. 다른 스터디원 분들이 올려주시는 코드를 보면서 문제를 해결하는 방법을 다양하게 고민해 볼 수 있었다. 다양한 배경을 가진 스터디원 분들이 색다른 아이디어로 졸업작품을 만들어주셔서 많은 영감을 받았다. 스터디에서만 할 수 있었던 틱톡 클론과 애니메이션 마스터 강의 챌린지 과제들이 많은 도움이 되었다. 기획 요구사항과 UI를 전달받아 개발하는 업무 흐름을 비슷하게 겪어보면서 Flutter로 복잡한 UI를 구현하는 과정에 빠르게 익숙해 질 수 있었다. 아쉬웠던 점 실제로 장소를 빌려 모여서 공부하고 뒤풀이를 하는 오프라인 모각코를 개인 사정으로 두 번 모두 참석하지 못했다. 스터디가 끝난 뒤 오프라인 종강파티도 감기몸살 때문에 참석하지 못했다. 인천 송도에서 Google I/O Extended 행사에 몇몇 스터디원 분들과 함께 참여했지만 컨디션이 좋지 않아서 중간에 따로 나올 수 밖에 없었다. 인사도 제대로 하지 못하고 나와서 아쉬웠다. 배운 점 이전까지는 ChatGPT 같은 GenAI를 개발할 때 사용하는걸 꺼려왔는데, 다른 분들이 ChatGPT를 적절하게 활용해서 완성도 높은 app을 개발하는 것을 보며 편견을 갖고 있다는 걸 느꼈다. 지금부터라도 AI와 함께 개발하는 것을 조금씩 연습해 봐야겠다고 생각했다. 조금씩 매일 하는 것이 가장 중요하다는 것을 다시 한번 느꼈다. 10주 스터디가 중반 이상 넘어가는 시점에는 살짝 루즈해져서 집중하기 어려운 날이 많았지만, 아무리 힘들어도 하루에 10분짜리 강의 한 개라도 꼭 들으려고 노력했다. 이렇게 매일 조금이라도 목표를 달성하는 경험이 쌓여서 10주동안 완강과 과제 개근이라는 결과를 낼 수 있었다. 앞으로 바라는 점 스터디를 통해 Flutter에 익숙해졌으니 스터디가 끝난 뒤에는 평소 생각해 두었던 아이디어를 실제로 개발해 볼 예정이다. iOS 개발 경력과 Flutter 개발 능력을 잘 살려서 Flutter 개발자로 취업할 계획도 갖고 있다. 한번 더 회사에서 일해 보면서 다양한 경험을 쌓아 봐도 좋을 것 같다. ","permalink":"https://cskime.github.io/posts/nomadcoders-flutter-study-review/","summary":"나는 iOS 개발자로 일하다가 지난 해 퇴사 후 안식년을 갖고 있다. 쉬는 동안 개발자라는 직업에 대한 고민을 많이 하고 있는데, 나는 어떤 개발자가 되고 싶은지 방향성을 잃어가고 있다는 생각이 들었기 때문이다. 개발하는 것 자체는 즐거운 일이지만 개발자라는 직업이 정말 나와 맞는지, 개발자를 오래 할 수 있을지 확신이 들지 않았다. 그래서, 쉬는 동안 다양한 개발 분야를 넓게 경험해보면서 생각을 정리해보고 있다.\nFlutter 10주 스터디 전에도 노마드코더에서 웹 기초 10주 스터디에 참여했던 적이 있다.","title":"Nomadcoders Flutter 10주 스터디 후기"},{"content":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod # needed when you reclone your repo (submodules may not get cloned automatically) $ git submodule update --init --recursive Theme update $ git submodule update --remote --merge hugo.yaml에 theme 명시 (구 config.yaml)\ntheme: [\u0026#34;PageMod\u0026#34;] Customizing \u0026lt;img\u0026gt; tag로 post에 image 추가하기 참고 : PaperMod and Hugo tweaks\nhugo.yaml에 아래 설정 추가 markup: goldmark: renderer: unsafe: true # 이 설정이 없으면 \u0026lt;img\u0026gt; tag를 사용할 수 없다. Markdown 문법(![]())을 사용하면 이 설정이 없어도 되지만 image size를 조절할 수 없다. Post 구조를 아래와 같이 변경 contents ㄴ posts ㄴ post-1 ㄴ index.md ㄴ image.jpg Markdown 안에서 \u0026lt;img\u0026gt; tag로 image 추가 \u0026lt;img src=\u0026#34;./image.jpg\u0026#34; width=\u0026#34;300\u0026#34; /\u0026gt; Menu /content 경로에 menu page를 markdown file로 생성 Archive page 설정 Search page 설정 hugo.yaml에 menu 설정 추가 (참고) Deploy to GitHub Repository 두 개 생성 (실제로 website로 보여지는 파일들은 /public에 있으므로 저장소 분리)\nblog source : blog source를 upload할 repository {username}.github.io : public directory를 upload할 repository Remote repo로 추가\n# blog source repository $ git remote add origin https://github.com/username/blog-source.git # public directory만 submodule로 따로 관리 $ git submodule add -b main https://github.com/username/username.github.io.git public # Submodule 등록 확인 $ ll .git/modules submodule에 theme과 public directory 두 개가 등록되어 있다면 정상적으로 등록된 것 만약, fatal: 'public' already exists and is not a valid git repo 과 같은 error가 발생하면 public 폴더를 삭제한 뒤 재시도 Root와 /public에서 각각 git remote -v를 실행하면 서로 다른 repository가 등록되어 있는 것을 확인 배포 script\n블로그를 배포할 때 blog-source와 {username}.github.io 두 repository에 각각 push해야 함 배포 과정을 script로 작성해서 사용 (참고) Reference Hugo Documentation PaperMod\u0026rsquo;s Demo hugo-PaperMod WiKi PaperMod 테마를 Hugo 사이트에 적용하는 방법 Hugo 블로그 생성 과정 (theme PaperMod) ","permalink":"https://cskime.github.io/posts/github-pages-hugo-papermod-blog/","summary":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.","title":"GitHub Pages와 Hugo PaperMod 테마로 블로그 만들기"},{"content":" Swift에서는 as?로 안전하게 type casting을 할 수 있었다.\nclass A {} class B: A {} class C {} let a = A() let b = B() b as? C// nil Dart는 as keyword로 type casting을 할 수 있지만, incompatible type으로 casting을 시도하면 type error가 발생한다. Dart에는 optional casting 연산자가 따로 없으므로, error 없이 type casting을 하려면 type check를 먼저 해야 한다.\nclass A {} class B extends A {} class C {} final a = A(); final b = B(); a as C // ❗️ type error if (a is C) { a as C // Never executed } if (a is B) { a as B // ✅ OK } 매번 type check를 하려면 번거로우므로, 아래와 같은 extension을 만들어서 사용하면 편리하다.\nextension SafeTypeCast on Object? { T? asOrNull\u0026lt;T\u0026gt;() { var self = this; return self is T ? self : null; } } a.asOrNull\u0026lt;B\u0026gt;();// OK 참고 https://github.com/dart-lang/language/issues/399 https://www.dhiwise.com/post/the-ultimate-guide-to-dart-type-cast-converting-data-types ","permalink":"https://cskime.github.io/posts/dart-safe-type-cast/","summary":"Swift에서는 as?로 안전하게 type casting을 할 수 있었다.\nclass A {} class B: A {} class C {} let a = A() let b = B() b as? C// nil Dart는 as keyword로 type casting을 할 수 있지만, incompatible type으로 casting을 시도하면 type error가 발생한다. Dart에는 optional casting 연산자가 따로 없으므로, error 없이 type casting을 하려면 type check를 먼저 해야 한다.\nclass A {} class B extends A {} class C {} final a = A(); final b = B(); a as C // ❗️ type error if (a is C) { a as C // Never executed } if (a is B) { a as B // ✅ OK } 매번 type check를 하려면 번거로우므로, 아래와 같은 extension을 만들어서 사용하면 편리하다.","title":"[Dart] Dart에서 type casting을 안전하게 하는 방법"},{"content":"개발 동기 노마드코더 챌린지 과제 중 아래와 같은 text UI를 구현하는 부분이 있었다. 회원가입 중 이용 약관이나 개인 정보 처리 방침 등을 사용자에게 안내하고 관련 외부 문서로 이동하여 확인할 수 있게 만드는 보편적인 UI 이다.\nFlutter에서 text에 다양한 style을 적용할 때 RichText 또는 Text.rich를 사용하므로, 이 UI를 구현하기 위해 아래와 같이 코드를 작성했다.\n이렇게 코드를 작성하면 몇 가지 문제가 있다.\n다른 style을 사용할 text를 직접 분류해서 나누어 작성해야 하므로 실수할 가능성이 있다. TextSpan이 중첩되는 구조이므로 어떤 text에 다른 style을 적용하는지 직관적으로 파악하기 어려워서 요구사항이 바뀌면 유지보수하기 어렵다. TextSpan을 어떻게, 얼마나 중첩시켜야 하는지에 대한 기준이 없다. 코드를 일관되게 작성하기 어렵다. 첫 번째 TextSpan.children에 다른 모든 TextSpan을 넣어도 동작에 차이가 없으므로, 사람에 따라 다른 style로 코드를 작성하게 된다. 만약, grouping 할 목적으로 두 번 이상 중첩한다면 indent depth가 깊어져 가독성이 떨어진다. 이런 문제를 해결하고 최대한 단순하고 직관적으로 구현할 수 있는 방법을 고민해 보다가, 이런 종류의 text UI를 쉽게 만들 수 있는 widget을 직접 만들어보기로 했다.\n설계 아래 세 가지 단계로 개발할 수 있게 되는 것을 목표로 한다.\n전체 문장을 주고, style을 바꾸고 싶은 단어 목록을 전달하면, 전체 문장에서 해당 단어들을 찾아 지정한 style 적용 이를 위해, text를 rendering하는 widget은 constructor를 통해 아래 속성을 초기화한다.\ntext : 전체 text (String type) words : style을 바꾸고 싶은 단어 목록 여기서 words는 List\u0026lt;Word\u0026gt; type의 값을 받는다. Word 객체는 constructor로 두 가지 값을 초기화한다.\ntext : 단어 (String type) style : 단어에 적용할 style 결과적으로, 아래와 같이 사용하는 것을 목표로 한다.\nMyTextWidget( text: \u0026#34;This is an entire text.\u0026#34;, words: [ Word(text: \u0026#34;entire\u0026#34;, style: TextStyle(~)), Word(text: \u0026#34;text\u0026#34;, style: TextStyle(~)), ], ) 개발 과정 1차 개발 처음에는 특정 단어를 선택하면 그에 해당하는 외부 web page로 이동할 수 있도록 개발했다.\n단어에 하이퍼링크를 추가하는 것임을 나타내기 위해 Link라는 class를 만들고, 해당 단어를 선택했을 때 외부에서 web page로 이동하는 코드를 작성할 수 있도록 constructor를 통해 callback 함수를 등록하도록 개발했다. 그리고, 전체 text와 하이퍼링크를 걸 단어 목록 List\u0026lt;Link\u0026gt;를 전달받아 Link에 해당하는 단어들에 style을 입히고 callback 함수를 등록해 주는 LinkableText class를 구현했다.\nLinkableText은 아래 과정을 거쳐 Link.text에 해당하는 단어들에 style을 적용하고 callback을 등록한다.\nlinks로 전달된 단어들을 순회하며 전체 text에서 해당 단어들의 위치(index) 저장 Index를 기준으로 links를 오름차순 정렬 links로 전달하는 단어들이 전체 text에 나타나는 순서와 다른 경우를 고려하여 정렬 정렬된 단어들을 순회하며 전체 text를 기준으로 split Split된 단어들과 links 단어들을 번갈아가며 List\u0026lt;TextSpan\u0026gt;에 저장 생성된 List\u0026lt;TextSpan\u0026gt;으로 Text.rich를 만들어서 반환 최종적으로 구현된 LinkableText와 Link는 아래와 같이 사용할 수 있다.\n2차 개발 LinkableText는 대부분의 경우 의도한 대로 잘 동작하지만, links에 같은 단어가 두 번 이상 들어있는 경우 특정 위치의 단어에만 style을 적용하기 어렵다는 단점이 있었다. 가령, 두 번째 나타나는 단어에만 style을 적용하려는 경우에도 첫 번째 나타나는 단어가 links에 들어있어야 한다. Style을 적용하지 않을 단어는 links에 추가하지 않았으면 좋겠다.\n또, “Link”라는 이름에 비해 기능이 너무 추상적이기도 했다. URL에 대한 하이퍼링크를 만드는게 아니라, text에 부분적으로 style을 적용하고 tap 할 수 있는 기능을 추가하는 것에 가깝다.\n이런 문제점을 개선하고 더 범용적으로 사용될 수 있도록 추상화한 CustomizableText widget을 개발하고, style을 더 세밀하게 변경할 수 있도록 인터페이스를 추가했다.\n변경 사항은 아래와 같다.\n이름에서 “link” 제거 LinkableText → CustomizableText links → customizes Link → CustomText span (new) callback → onTap Style을 설정할 수 있는 속성 추가 (아래로 갈 수록 style이 override 된다.) CustomizableText.style : 전체 text에 적용되는 style CustomizableText.customStyle : 전체 custom text들에 적용되는 style CustomText.style : custom text 1개에 적용되는 style 특정 위치의 text에만 style을 적용할 수 있도록 개선 span 값을 사용해서 특정 위치의 단어에만 style을 적용할 수 있도록 개선했다. span으로 전체 text에서 두 번 이상 나타나는 단어 중 임의의 위치에 있는 단어를 식별할 수 있다. 이 기능은 기존 LinkableText에서 style을 적용하지 않을 단어까지 links에 넣어야 하는 문제를 해결한다. 내부 정렬 알고리즘을 개선했습니다. Before : Map으로 단어 별 index들을 기록한 뒤 정렬 After : allMatches method를 사용해서 단어들의 정렬된 index를 얻음 Closing CustomizableText를 사용하여 위와 같은 text UI를 직관적이고 쉽게 그릴 수 있었다. CustomizableText는 어떤 프로젝트에서도 다양하게 활용될 수 있을 것 같아서 pub.dev에 배포하는 경험도 할 수 있었다. (customizable_text package | pub.dev)\n배포를 하고 나서 개선할 것들이 더 눈에 띄었다. pub.dev에 패키지를 올리면 score가 매겨지는데, documentation이 부족하여 만점을 받지 못했다. Package로 만든 이상, API documentation을 제대로 해 두는게 필요해 보였다. 또, tap 외에도 long press 등 다른 gesture에 대한 callback을 추가할 수 있으면 더 좋을 것 같다. Static color가 아닌 gradient나 shadow 등 다른 형태의 style을 입힐 수 있게 만들어도 좋을 것 같다.\n","permalink":"https://cskime.github.io/posts/customizable_text_package_review/","summary":"개발 동기 노마드코더 챌린지 과제 중 아래와 같은 text UI를 구현하는 부분이 있었다. 회원가입 중 이용 약관이나 개인 정보 처리 방침 등을 사용자에게 안내하고 관련 외부 문서로 이동하여 확인할 수 있게 만드는 보편적인 UI 이다.\nFlutter에서 text에 다양한 style을 적용할 때 RichText 또는 Text.rich를 사용하므로, 이 UI를 구현하기 위해 아래와 같이 코드를 작성했다.\n이렇게 코드를 작성하면 몇 가지 문제가 있다.\n다른 style을 사용할 text를 직접 분류해서 나누어 작성해야 하므로 실수할 가능성이 있다.","title":"[Flutter] 'customizable_text' package 개발 기록"},{"content":"Flutter Constraint와 Layout Flutter는 3단계를 거쳐 widget의 layout을 결정한다.\nConstraints go down : Parent widget이 child widget에 constraint를 제안한다. Sizes go up : Child widget은 constraint 범위 내의 size를 parent widget에 알려준다. Parent sets position : Parent widget은 자신의 alignment 정보와 child widget size를 사용해서 child widget의 position을 결정한다. 여기서 \u0026ldquo;constraint\u0026ldquo;란 size의 최대 ~ 최소값의 범위를 말한다. Flutter에서는 BoxConstraints class를 주로 사용하여 minWidth, minHeight, maxWidth, maxHeight을 정의한다.\nconst BoxConstraints({ this.minWidth = 0.0, this.maxWidth = double.infinity, this.minHeight = 0.0, this.maxHeight = double.infinity, }); 여기서 주의할 점은, constraint는 size의 범위를 제한하는 것이므로 child widget의 size 또한 이 constraint 범위 안에 있어야 한다는 것이다. Child widget size가 parent가 제안한 constraint 범위를 벗어나면 \u0026ldquo;A RenderFlex overflowed\u0026hellip;\u0026rdquo; error가 발생한다.\nTight vs loose constraints Tight constraint min == max인 경우로, exact size를 갖게 만든다. BoxConstraints.tight(Size size) : minWidth = size.width, maxWidth = size.width, minHeight = size.height, maxHeight = size.height; App widget은 child widget을 전체 screen에 딱 맞게 만드는데, screen size에 대한 tight constraint가 적용된 것임 Loose constraint min == 0 \u0026lt; max인 경우로, child widget이 범위 내에서 own size를 가질 수 있게 한다. Center widget은 parent로부터 받은 tight constraint를 loose constraint로 바꿔서 child에 전달하는 목적이기도 함 Bounded vs Unbounded Bounded constraint max \u0026lt; infinity인 경우 Widget 크기가 min ~ max 범위 안에서 결정됨 Unbounded constraint max == infinity인 경우 Size 제약이 없는 상태이므로 box는 가능한 최대 size로 커지려고 한다. Column, Row 같은 Flex box 또는 ListView, ScrollView subclass들 같은 scrollable region이 unbounded constraint를 갖는다. 발생할 수 있는 문제 ListView의 scroll 영역은 main axis 방향으로 무한대 크기를 허용함 children중 main axis와 같은 방향으로 크기가 무한대로 확장하는 widget이 있다면 unbound layout error가 발생한다. e.g. 크기가 고정되지 않은 ListView 안에서 Column, Row 등 flexible widget 사용 둘 중 하나는 SizedBox로 크기를 고정하거나 BoxConstraint로 제약을 추가해야 한다. Flutter Widgets들의 Size 규칙 Flutter widget들이 size를 결정하는 규칙은 아래와 같다.\n가능한 영역을 꽉 채우는 size를 사용하는 widget (e.g. Center, Align, ListView) Child widget과 동일한 size를 사용하는 widget (e.g. Transform, Opacity) Content size를 사용하는 widget (e.g. Image, Text) 특히, Container widget은 어떤 속성을 사용하는지에 따라 동작하는 방식이 달라진다.\n기본적으로 가능한 영역을 꽉 채우는 size를 사용한다. (1번) width, height 등 size가 지정되면 해당 size를 사용한다. (3번) child widget을 갖는 경우, child widget size를 사용한다. (2번) Reference Understanding constraints | Flutter Dev Flutter의 제약(constraint) 이해하기 | Tistory ","permalink":"https://cskime.github.io/posts/flutter-constraints/","summary":"Flutter Constraint와 Layout Flutter는 3단계를 거쳐 widget의 layout을 결정한다.\nConstraints go down : Parent widget이 child widget에 constraint를 제안한다. Sizes go up : Child widget은 constraint 범위 내의 size를 parent widget에 알려준다. Parent sets position : Parent widget은 자신의 alignment 정보와 child widget size를 사용해서 child widget의 position을 결정한다. 여기서 \u0026ldquo;constraint\u0026ldquo;란 size의 최대 ~ 최소값의 범위를 말한다. Flutter에서는 BoxConstraints class를 주로 사용하여 minWidth, minHeight, maxWidth, maxHeight을 정의한다.\nconst BoxConstraints({ this.minWidth = 0.","title":"[Flutter] Flutter Constraint 이해하기"},{"content":" TabBar의 isScrollable을 true로 설정하면 왼쪽에 default padding이 잡힘 Flutter 3.16.0 버전부터 Material 3 디자인이 적용되면서, isScrollable이 true일 때 tabAlignment 속성의 기본값이 TabAlignment.startOffset이 됨 Material3 에서 TabBar의 기본 alignment Material2 에서 TabBar의 기본 alignment TabAlignment.startOffset은 왼쪽에 52px offset을 추가하기 때문에 왼쪽에 여백이 생기는 것 따라서, 아래 세 가지 방법으로 left offset을 제거할 수 있다. Material 3를 사용하지 않도록 설정 TabBar.tabAlignment를 TabAlignment.start로 설정 TabBar.padding에 EdgeInsets.only(left: 10)처럼 원하는 offset으로 override Reference Scrollable Tabs have a gap on the left | GitHub Issue Customizing tabs alignment using the new TabBar.tabAlignment property | Flutter Docs ","permalink":"https://cskime.github.io/posts/tabbar-remove-left-padding/","summary":"TabBar의 isScrollable을 true로 설정하면 왼쪽에 default padding이 잡힘 Flutter 3.16.0 버전부터 Material 3 디자인이 적용되면서, isScrollable이 true일 때 tabAlignment 속성의 기본값이 TabAlignment.startOffset이 됨 Material3 에서 TabBar의 기본 alignment Material2 에서 TabBar의 기본 alignment TabAlignment.startOffset은 왼쪽에 52px offset을 추가하기 때문에 왼쪽에 여백이 생기는 것 따라서, 아래 세 가지 방법으로 left offset을 제거할 수 있다. Material 3를 사용하지 않도록 설정 TabBar.tabAlignment를 TabAlignment.start로 설정 TabBar.padding에 EdgeInsets.only(left: 10)처럼 원하는 offset으로 override Reference Scrollable Tabs have a gap on the left | GitHub Issue Customizing tabs alignment using the new TabBar.","title":"[Flutter] Scrollable TabBar의 왼쪽 여백 제거하기"},{"content":"문제 상황 ListView를 Clip.none으로 설정하면 item들이 scroll될 때 ListView의 실제 영역을 벗어나서 화면 밖으로 사라질 때 까지 화면에 유지될 것이라고 예상 하지만 실제로는 item이 화면 밖으로 나가기 전에 먼저 화면에서 사라짐 이 ListView는 Padding 및 다른 widget들의 하위 widget 원인 분석 Flutter GitHub에 이미 같은 문제로 issue가 올라왔었다. 이 repo의 contributor에 따르면, 이것은 의도된 동작이라고 한다. it looks like this is working as intended.. The Padding around the ListView is what is causing this effect. The padding makes the viewport of the ListView smaller, although it is not visibly apparent. Then with Clip.none set, the bounds of that viewport are not clipped, so you can see as the items exit they are disposed since they are outside of the actual scrolling window due to the Padding.\n즉, ListView나 PageView같은 scrollable widget들의 item이 화면에서 사라지는 시점은 screen 밖으로 나갈 때가 아닌 \u0026ldquo;해당 widget의 viewport 밖으로 완전히 나갈 때\u0026ldquo;이다. 문제 상황에서 item이 사라지는 지점도 ListView 영역을 완전히 벗어나는 지점과 일치한다. 문제 해결 ListView item들이 화면 밖으로 완전히 나갈 때 까지는 화면에 표시되기를 원하므로, ListView의 viewport가 screen size와 동일하게 만들어주면 문제를 해결할 수 있다. ListView를 감싸고 있는 Padding widget이 horizontal inset을 갖지 않게 만들고, padding 역할을 하는 빈 widget을 ListView의 양 끝에 추가해 준다. 이제 ListView의 viewport와 screen size가 같으므로 item이 화면 밖으로 나갈 때 까지 화면에 보여진다. ","permalink":"https://cskime.github.io/posts/listview-clip-item-disappear/","summary":"문제 상황 ListView를 Clip.none으로 설정하면 item들이 scroll될 때 ListView의 실제 영역을 벗어나서 화면 밖으로 사라질 때 까지 화면에 유지될 것이라고 예상 하지만 실제로는 item이 화면 밖으로 나가기 전에 먼저 화면에서 사라짐 이 ListView는 Padding 및 다른 widget들의 하위 widget 원인 분석 Flutter GitHub에 이미 같은 문제로 issue가 올라왔었다. 이 repo의 contributor에 따르면, 이것은 의도된 동작이라고 한다. it looks like this is working as intended.. The Padding around the ListView is what is causing this effect.","title":"[Flutter] ListView에 Clip.none 설정 시 item이 사라지는 문제"},{"content":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider? of(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;CounterProvider\u0026gt;(); } 공유 상태를 관리하기 위한 StatefulWidget 생성\nclass CounterScope extends StatefulWidget { const CounterScope({ super.key, required this.child, }); final Widget child; @override State\u0026lt;CounterScope\u0026gt; createState() =\u0026gt; _CounterScopeState(); } class _CounterScopeState extends State\u0026lt;CounterScope\u0026gt; { // ✅ 실제 상태 값 관리 : 상태 저장 및 갱신(setState) int counter = 0; void incrementCounter() { setState(() { counter++; }); } @override Widget build(BuildContext context) { return CounterProvider( counter: counter, incrementCounter: incrementCounter, child: widget.child, ); } } MyApp의 home에서 CounterScope를 HomeScreen의 상위 widget으로 추가\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ CounterScope가 HomeScreen의 상위 widget이 됨 home: const CounterScope(child: HomeScreen()), ); } } 문제 재현 HomeScreen에서는 CounterProvider에 접근할 수 있음\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: ..., body: Center( child: CountLabel( counter: CounterProvider.of(context)?.counter ?? -1, // ✅ ), ), floatingActionButton: IncrementButton( onPressed: CounterProvider.of(context)?.incrementCounter, // ✅ ), ); } } Navigator.push로 DetailScreen으로 이동\n// 버튼 callback onPressed: () =\u0026gt; Navigator.of(context).push( MaterialPageRoute( builder: (context) =\u0026gt; const DetailScreen(), ), ), DetailScreen에서는 CounterProvider에 접근할 수 없음\n// 버튼 callback class DetailScreen extends StatelessWidget { const DetailScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;Detail Page\u0026#39;), ), body: Center( child: CountLabel( // ❌ : null을 반환하므로 label에 \u0026#39;-1\u0026#39; 표시 counter: CounterProvider.of(context)?.counter ?? -1, ), ), floatingActionButton: IncrementButton( // ❌ : null을 반환하므로 counter가 동작하지 않음 onPressed: CounterProvider.of(context)?.incrementCounter, ), ); } } 원인 분석 InheritedWidget에 접근하는 방식 BuildContext.dependOnInheritedWidgetOfExactType은 현재 widget에서 widget tree상의 상위 widget을 찾아서 반환함 즉, BuildContext.dependOnInheritedWidgetOfExactType이 null이면 widget tree에서 상위에InheritedWidget이 존재하지 않는다는 것 Navigator.of(context).push의 동작 방식 MaterialApp은 내부에서 Navigator를 만들고 widget tree에 추가한다. MaterialApp.home에 전달하는 widget은 이 최상위 Navigator의 child widget이 된다. MaterialApp ㄴ Navigator ㄴ HomeScreen Widget에서 Navigator.of(context)을 호출하면 MaterialApp이 생성한 최상위 Navigator를 얻는다. Screen A에서 screen B로 Navigator.push를 통해 화면을 전환하면, 최상위 Navigator의 하위에 screen B를 추가하며 화면에 렌더링한다. 즉, screen A와 B는 같은 root Navigator에 의해 sibling 관계로 widget tree에 추가된다. 문제 발생 원인 Widget tree를 열어보면 DetailScreen과 CounterProvider가 ancestor-descendant 관계가 아닌 sibling 관계인 것을 확인할 수 있음 BuildContext.dependOnInheritedWidgetOfExactType는 widget tree상의 ancestor InheritedWidget을 찾는 것이므로, sibling 관계에서는 접근할 수 없다. HomeScreen에서는 CounterProvider가 direct ancestor widget이기 때문에 CounterProvider에 정상적으로 접근할 수 있었다. 해결 방법 CounterProvider와 DetailScreen을 ancestor-descendant 관계로 만들어 준다.\nHomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 (MaterialApp 위) HomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 관련 코드\nHomeScreen을 아래와 같이 수정한다.\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { // ✅ HomeScreen 하위에 Navigator 추가 // 이제 `Navigator.of(context)`는 이 Navigator를 반환한다. return Navigator( onGenerateRoute: (settings) =\u0026gt; MaterialPageRoute( builder: (context) =\u0026gt; ..., // 원래 widget 덩어리 반환 ), ); } } HomeScreen의 build() method에서 Navigator를 반환한다. Navigator의 onGenerateRoute 함수에서 MaterialPageRoute를 반환한다. MaterialPageRoute의 builder 함수에서 HomeScreen을 구성하는 Scaffold widget 덩어리를 반환한다. 이제 HomeScreen에서 Navigator.of(context)를 호출하면 최상위 Navigator가 아닌 HomeScreen의 하위 Navigator를 사용하므로 DetailScreen이 HomeScreen의 child widget으로 추가된다. InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 관련 코드\nDetailScreen이 MaterialApp 아래에서 InheritedWidget을 child로 갖는 HomeScreen과 sibling 관계를 갖는 것이 문제이므로, InheritedWidget을 MaterialApp의 상위 widget으로 올려서 HomeScreen과 DetailScreen의 공통 ancestor widget이 될 수 있게 만든다.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { // ✅ CounterScope와 CounterProvider가 MaterialApp보다 상위 widget이 된다. return CounterScope( child: MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ `HomeScreen`을 감싸고 있던 CounterScope는 제거한다. home: const HomeScreen(), ), ); } } 이제 HomeScreen과 DetailScreen이 sigling 관계여도 CounterProvider를 공통 ancestor로 가지므로, 두 widget 모두 BuildContext를 통해 CounterProvider에 접근할 수 있다.\n결론 Navigator.of(context)는 MaterialApp이 만드는 최상위 Navigator에 접근한다. Navigator.push는 route widget을 Navigator의 child로 추가한다. 여러 화면에서 공통으로 사용되는 state는 navigation 이후 widget tree 구조를 고려해서 위치시켜야 한다. Navigator를 직접 추가하는 방법은 history를 모르면 예상치 못한 버그가 발생할 우려가 있으므로, InheritedWidget을 Navigator보다 상위에 위치시키는 방법이 더 좋아 보인다. Riverpod에서 ProviderScope가 runApp 바로 아래에서 MyApp을 wrapping하게 만드는 이유를 조금이나마 이해했다. ProviderScope는 내부 build() method에서 InheritedWidget을 상속받는 UncontrolledProviderScope를 반환한다. Riverpod도 비슷한 문제를 해결하기 위해 최상위에 InheritedWidget을 놓으려는 시도를 한 것 같다. 참고 Navigator class | flutter.io MaterialApp class | flutter.io ","permalink":"https://cskime.github.io/posts/inherited-widget-unaccessible/","summary":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider?","title":"[Flutter] Navigator.push로 띄운 widget에서 InheritedWidget에 접근할 수 없는 문제"},{"content":"위도와 경도 위도(latitude) : 적도를 기준으로 북쪽 또는 남쪽으로 떨어진 위치 (도(°) 단위) 경도(longitude) : 본초 자오선을 기준으로 동쪽 또는 서쪽으로 떨어진 위치 (도(°) 단위) 180°E ~ 180°W (동경 180° ~ 서경 180°) 까지의 범위 안에 위치 경도 15°로 1시간의 시차가 생긴다. 자오선 자오선(Meridian) 또는 경선 북극점과 남극점을 최단 거리로 연결하는 세로선 동경(E, X E, X East) : 자오선의 동쪽 서경(W, Y W, Y West) : 자오선의 서쪽 동경과 서경은 180°까지 있고, 동서경 180°는 일치한다. 본초 자오선(prime meridian) 영국 그리니치 천문대를 지나는 자오선 (경도 0°) 정오 (낮 12시)의 기준이 된다. 날짜 변경선 (International Date Line) 경도 180°를 기준으로 날짜를 구분하는 선 그리니치 천문대를 기준으로 180°W ~ 180°E 끝에서 날짜가 바뀌도록 기준으로 만든 것 시간대 (Timezone) 본초 자오선을 기준으로 지역에 따른 시간 차이를 조정하기 위해 만든 구분선 또는 범위 지역 별 경도값에 따라 기준시(GMT)로부터 시간 차이를 계산해서 각 지역마다 시간을 보정한다. 표기법 GMT 기준 : GMT (+/-) 시차 UTC 기준 : UTC (+/-) 시차 참고 Time zone map GMT(Greenwich Mean Time) 그리니치 평균시/표준시(GMT, Greenwich Mean Time) 그리니치 천문대를 기준으로 하는 기준 시간, 평균시 협정 세계시의 기준 시간대 UTC(Universal Time Coordinated) 협정 세계시(UTC) 1972년 1월 1일부터 시행된 국제 표준시 영어로 \u0026lsquo;Coordinated Universal Time’, 프랑스어로 \u0026lsquo;Temps Universel Coordonné\u0026lsquo;이지만 영국과 프랑스의 분쟁으로 인해 두 나라의 표기법과 겹치지 않는 \u0026ldquo;UTC\u0026quot;로 표기 1970년 1월 1일 자정을 기준으로 0ms부터 시간을 계산한다. GMT에 국제 원자시와 윤초 보정을 한 것 GMT와 초의 소수점 단위에서만 차이가 나므로, 일반적으로 UTC와 GMT를 혼용한다. Etc/GMT POSIX 시스템의 시간대 표기법 중 하나 GMT/UTC와 동일한 시간대를 가리키지만, 표기법에 차이가 있다. Etc/GMT+1은 GMT보다 1시간 앞서 가는 시간대를 나타낸다. 1시간 앞서가므로, Etc/GMT+1은 GMT-1 또는 UTC-1과 같다. DST(Daylight Saving Time) 일광 절약 시간제(Daylight Saving Time) 또는 Summer Time 하절기에 표준시를 원래 시간보다 한 시간 앞당겨서 사용하는 것 2시부터 summer time을 적용하면, 시간을 3시로 조정 캘리포니아의 경우, GMT-8 시간대에 속하지만 summer time을 적용하면 GMT-7이 된다. ❓ GMT+16은 없는 이유 미국 캘리포니아는 GMT-8 시간대에 속하고, summer time을 적용하면 GMT-7 시간대에 속한다. 이것은 캘리포니아가 그리니치 천문대를 기준으로 서쪽에 있다고 보기 때문인데, 그리니치 천문대의 동쪽으로 쭉 가다 보면 캘리포니아를 만날 것이므로 GMT+16이라고 표기할 수 있는지 궁금하다.\n우선, 시간대는 GMT-11 ~ GMT+14 까지밖에 정의되어 있지 않으므로 GMT+16이라고 쓸 수는 없다. 그럼 왜 GMT+14 까지 밖에 없는가?\n180°W, 180°E 는 각각 날짜 변경선의 기준이 된다. 즉, 시간대가 변경되는 범위는 이 날짜 변경선 안에서 정해진다. GMT+16은 날짜 변경선(180°E)을 넘어서는 시간대이므로 하루를 표현하는 시간대 안에서 존재할 수 없다.\nGMT+13, GMT+14 등의 시간대는 날짜 변경선(180°E) 을 조금 넘어서 있는데, 날짜 변경선에 걸쳐있는 국가들 중 일부는 날짜를 사용하는 방식에 따라 자체적으로 시간을 보정하기 때문에 이것을 반영한 것이다. 예를 들어, 어떤 나라에서 12월 30일을 없애기로 했다면 그에 맞게 날짜 변경선이 달라질 수 있고, 그 국가를 지나지 않는 선을 만들면서 부분적으로 날짜 변경선을 넘어서는 시간대가 정의될 수 있다.\nLocale 사용자의 언어, 지역 설정, 출력 형식 등을 정의한 문자열 POSIX 기반 시스템에서는 같은 형식을 공유한다. (Unix, Linux, macOS 등) Locale 형식을 변경하여 출력 및 동작 방식을 변경할 수 있다. 형식 [language]_[territory].[codeset][@modifier] language : 언어 (ISO 639-1 표준 형식을 따름) territory : 국가 또는 지역 (ISO 3166-1 표준 형식을 따름) codeset : 인코딩 codeset (e.g. UTF-8) Example 한국어로, 한국에서, UTF-8 인코딩을 사용하는 경우 ko_KR.UTF-8 언어와 국가는 개별적으로 설정할 수 있다. en_US.UTF-8 : 영어, 미국 en_CA.UTF-8 : 영어, 캐나다 종류 POSIX Locale POSIX(Portable Operating System Interface) 이식 가능 운영체제 인터페이스 서로 다른 UNIX OS의 공통 API를 정리하여 이식성 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격 POSIX 시스템의 기본 locale로, 미리 정의된 형식으로 날짜를 출력한다. en_US_POSIX POSIX 규격에서 정의한 locale 설정을 사용한다. 개발할 때 사용자의 국가에 관계 없이 동일한 date format을 사용하려면 이 locale을 사용해야 한다. C Locale C 언어에서 정의하는 locale POSIX 계열 운영체제에서는 C와 POSIX locale 혼용 참고 TimeZone, Locale, 날짜 표현 형식 개념 확실히 잡아보자! 한국표준시(KST)에 대한 흥미로운 이야기 세계 표준시 UTC, GMT와 한국 시간 KST 계산 방법 IBM: POSIX and Olson time zone formats 로케일(Locale)이란? 국가 및 언어 설정 ","permalink":"https://cskime.github.io/posts/all-about-date-and-time/","summary":"위도와 경도 위도(latitude) : 적도를 기준으로 북쪽 또는 남쪽으로 떨어진 위치 (도(°) 단위) 경도(longitude) : 본초 자오선을 기준으로 동쪽 또는 서쪽으로 떨어진 위치 (도(°) 단위) 180°E ~ 180°W (동경 180° ~ 서경 180°) 까지의 범위 안에 위치 경도 15°로 1시간의 시차가 생긴다. 자오선 자오선(Meridian) 또는 경선 북극점과 남극점을 최단 거리로 연결하는 세로선 동경(E, X E, X East) : 자오선의 동쪽 서경(W, Y W, Y West) : 자오선의 서쪽 동경과 서경은 180°까지 있고, 동서경 180°는 일치한다.","title":"All About Date and Time"},{"content":"Hit Testing Hit test는 사용자 event가 발생할 때 view 계층(hierarchy)에서 subview들을 탐색(traverse)하며 event를 처리할 view를 결정하는 과정이다. Root view부터 시작하여 subview들을 역방향으로 탐색하며, event 발생 위치(point)를 포함하는 view가 있다면 그 view의 subview들을 같은 방법으로 탐색해 나간다.\n\u0026lsquo;역방향\u0026rsquo;으로 탐색하는 이유는, 화면의 가장 앞에 위치한 view부터 탐색하기 위함이다. 여러 개의 view가 겹쳐있다면 사용자가 보게 되는 맨 앞의 view가 event를 가져가야 한다. 화면의 가장 앞에 있는 view는 다음과 같은 특징을 가진다.\nz-order index(depth)가 가장 크다. 형제 view(sibling view)들 중에서 subview index가 가장 크다. Tree 구조에서 이와 같은 탐색 방법을 **역방향 깊이 우선 탐색(Reverse Pre-Order Depth-First Traversal)**이라고 한다.\n아래 그림은 touch event가 발생했을 때 event를 처리할 view를 결정하는 과정을 보여준다.\nView 계층의 root view(UIWindow)부터 시작하여 touch point를 포함하는 subview들 중 가장 멀리 떨어진 view를 탐색한다. MainView의 subview들 중 index가 가장 큰 View C부터 탐색을 시작한다. View C는 touch point를 포함하지 않으므로 건너뛰고, View B를 탐색한다. View B는 touch point를 포함하고 있으므로, 그 subview들 중 index가 가장 큰 View B.2를 탐색한다. View B.2는 touch point를 포함하지 않으므로 건너뛰고, view B.1을 탐색한다. View B.1은 touch point를 포함하고 root로부터 가장 멀리 떨어진 view이므로, View B.2에 event를 전달한다. Hit Test 구현 Hit testing에서 event를 전달받을 후보 view가 되기 위해서는 다음 조건을 만족해야 한다.\nView가 화면에 보여야 한다. View가 user interaction이 가능해야 한다. View 영역이 event 발생 위치(point)를 포함해야 한다. View 계층에서 세 가지 조건을 만족하는 view를 찾기 위해 hitTest(_:with:) 함수를 다음과 같이 구현할 수 있다. 함수가 nil을 반환하는 것은 event를 받을 수 없는 view이므로 다음 view를 탐색하라는 의미이다.\nfunc hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // 1번 조건 검사 guard !isHidden, alpha \u0026gt; 0.01 else { return nil } // 2번 조건 검사 guard isUserInteractionEnabled else { return nil } // 역방향 탐색을 위해 subviews array를 뒤집어서(reversed) 탐색 for subview in subviews.reversed() { let point = subview.convert(point, from: self) guard let hitView = subview.hitTest(point, with: event) else { continue } // 재귀적으로 반환되는 hitView는 곧 subview를 의미한다. // 즉, subview에서 hit testing이 성공하면 subview가 자기 자신을 반환할 것이다. return hitView } // 3번 조건 검사 guard bounds.contains(point) else { return nil } return self } UIView에는 이런 방식으로 구현된 hitTest(_:with:) method가 이미 구현되어 있다. 만약, 어떤 view가 특정 조건에서 event를 수신하지 못하게 하려면 다음과 같이 override해서 사용할 수 있다.\nclass SomeView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // somCondition이 true일 때만 이 view에서 hit testing을 계속한다. guard someCondition else { return nil } return super.hitTest(point, with: event) } } 활용 Hit testing에서 반환되는 view를 조작하여 특정 상황에서만 event를 받을 수 있도록 구현할 수 있다.\n1. Passing through touch event 아래와 같이 5개의 UISwitch가 파란색 view로 덮여 있다. 스위치를 터치하더라도, 덮고 있는 view가 event를 가져가므로 스위치를 on/off할 수 없다.\n이 상황에서 스위치를 터치해서 on/off할 수 있게 만들려면, cover view에 event가 전달되지 않아야 하므로 event를 받기 위한 3가지 조건 중 한 가지를 만족하지 않도록 바꾸면 된다.\nUser interaction 비활성화 coverView.isUserInteractionEnabled = false View 숨김(Cover view가 반드시 보여야한다면, 이 방법은 사용하지 못할 것이다.) coverView.isHidden = true // or coverView.alpha = 0 hitTest(_:with:) 함수에서 nil 반환 class CoverView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { return nil } } 만약 특정 스위치만 on/off할 수 있게 만들려면 hitTest(_:with:) method를 override해서 nil을 반환하는 조건을 추가로 구현해야 한다.\nclass CoverView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { var hitView = super.hitTest(point, with: event) // 가운데 스위치가 있는 영역 let rect = bounds.insetBy(dx: bounds.width / 3, dy: bounds.height / 3) // Point가 가운데 영역(rect)에 포함될 때는 nil을 반환한다. guard rect.contains(point) else { return hitView } return nil } } 2. Throw touch event Hit testing을 통해 event를 받는 view는 hitTest(_:with:) method에서 반환되는 view이다. 즉, 실제로는 event를 받기 위한 3가지 조건을 만족하지 못하는 어떤 view를 임의로 hitTest(_:with:)에서 반환시키면 그 view도 event를 받아 처리할 수 있게 된다.\n다음은 이 방법을 사용하여 크기가 작은 버튼의 터치 영역을 확장시키는 예시이다.\nclass CustomButton: UIButton { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // Button 영역에서 상하좌우 10pt만큼 더 넓은 영역까지 touch point를 검사한다. let contains = bounds.insetBy(dx: -10, dy: -10).contains(point) return contains ? super.hitTest(point, with: event) : nil } } Reference http://smnh.me/hit-testing-in-ios/ https://developer.apple.com/documentation/uikit/uiview/1622469-hittest ","permalink":"https://cskime.github.io/posts/ios-hit-testing/","summary":"Hit Testing Hit test는 사용자 event가 발생할 때 view 계층(hierarchy)에서 subview들을 탐색(traverse)하며 event를 처리할 view를 결정하는 과정이다. Root view부터 시작하여 subview들을 역방향으로 탐색하며, event 발생 위치(point)를 포함하는 view가 있다면 그 view의 subview들을 같은 방법으로 탐색해 나간다.\n\u0026lsquo;역방향\u0026rsquo;으로 탐색하는 이유는, 화면의 가장 앞에 위치한 view부터 탐색하기 위함이다. 여러 개의 view가 겹쳐있다면 사용자가 보게 되는 맨 앞의 view가 event를 가져가야 한다. 화면의 가장 앞에 있는 view는 다음과 같은 특징을 가진다.\nz-order index(depth)가 가장 크다.","title":"[iOS] iOS Hit Testing"}]