[{"content":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod # needed when you reclone your repo (submodules may not get cloned automatically) $ git submodule update --init --recursive Theme update $ git submodule update --remote --merge hugo.yaml에 theme 명시 (구 config.yaml)\ntheme: [\u0026#34;PageMod\u0026#34;] Customizing Menu /content 경로에 menu page를 markdown file로 생성 Archive page 설정 Search page 설정 hugo.yaml에 menu 설정 추가 (참고) Deploy to GitHub Repository 두 개 생성 (실제로 website로 보여지는 파일들은 /public에 있으므로 저장소 분리)\nblog source : blog source를 upload할 repository {username}.github.io : public directory를 upload할 repository Remote repo로 추가\n# blog source repository $ git remote add origin https://github.com/username/blog-source.git # public directory만 submodule로 따로 관리 $ git submodule add -b main https://github.com/username/username.github.io.git public # Submodule 등록 확인 $ ll .git/modules submodule에 theme과 public directory 두 개가 등록되어 있다면 정상적으로 등록된 것 만약, fatal: 'public' already exists and is not a valid git repo 과 같은 error가 발생하면 public 폴더를 삭제한 뒤 재시도 Root와 /public에서 각각 git remote -v를 실행하면 서로 다른 repository가 등록되어 있는 것을 확인 배포 script\n블로그를 배포할 때 blog-source와 {username}.github.io 두 repository에 각각 push해야 함 배포 과정을 script로 작성해서 사용 (참고) Reference Hugo Documentation PaperMod\u0026rsquo;s Demo hugo-PaperMod WiKi PaperMod 테마를 Hugo 사이트에 적용하는 방법 Hugo 블로그 생성 과정 (theme PaperMod) ","permalink":"https://cskime.github.io/posts/github-pages-hugo-papermod-blog/","summary":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.","title":"GitHub Pages와 Hugo PaperMod 테마로 블로그 만들기"},{"content":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider? of(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;CounterProvider\u0026gt;(); } 공유 상태를 관리하기 위한 StatefulWidget 생성\nclass CounterScope extends StatefulWidget { const CounterScope({ super.key, required this.child, }); final Widget child; @override State\u0026lt;CounterScope\u0026gt; createState() =\u0026gt; _CounterScopeState(); } class _CounterScopeState extends State\u0026lt;CounterScope\u0026gt; { // ✅ 실제 상태 값 관리 : 상태 저장 및 갱신(setState) int counter = 0; void incrementCounter() { setState(() { counter++; }); } @override Widget build(BuildContext context) { return CounterProvider( counter: counter, incrementCounter: incrementCounter, child: widget.child, ); } } MyApp의 home에서 CounterScope를 HomeScreen의 상위 widget으로 추가\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ CounterScope가 HomeScreen의 상위 widget이 됨 home: const CounterScope(child: HomeScreen()), ); } } 문제 재현 HomeScreen에서는 CounterProvider에 접근할 수 있음\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: ..., body: Center( child: CountLabel( counter: CounterProvider.of(context)?.counter ?? -1, // ✅ ), ), floatingActionButton: IncrementButton( onPressed: CounterProvider.of(context)?.incrementCounter, // ✅ ), ); } } Navigator.push로 DetailScreen으로 이동\n// 버튼 callback onPressed: () =\u0026gt; Navigator.of(context).push( MaterialPageRoute( builder: (context) =\u0026gt; const DetailScreen(), ), ), DetailScreen에서는 CounterProvider에 접근할 수 없음\n// 버튼 callback class DetailScreen extends StatelessWidget { const DetailScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;Detail Page\u0026#39;), ), body: Center( child: CountLabel( // ❌ : null을 반환하므로 label에 \u0026#39;-1\u0026#39; 표시 counter: CounterProvider.of(context)?.counter ?? -1, ), ), floatingActionButton: IncrementButton( // ❌ : null을 반환하므로 counter가 동작하지 않음 onPressed: CounterProvider.of(context)?.incrementCounter, ), ); } } 원인 분석 InheritedWidget에 접근하는 방식 BuildContext.dependOnInheritedWidgetOfExactType은 현재 widget에서 widget tree상의 상위 widget을 찾아서 반환함 즉, BuildContext.dependOnInheritedWidgetOfExactType이 null이면 widget tree에서 상위에InheritedWidget이 존재하지 않는다는 것 Navigator.of(context).push의 동작 방식 MaterialApp은 내부에서 Navigator를 만들고 widget tree에 추가한다. MaterialApp.home에 전달하는 widget은 이 최상위 Navigator의 child widget이 된다. MaterialApp ㄴ Navigator ㄴ HomeScreen Widget에서 Navigator.of(context)을 호출하면 MaterialApp이 생성한 최상위 Navigator를 얻는다. Screen A에서 screen B로 Navigator.push를 통해 화면을 전환하면, 최상위 Navigator의 하위에 screen B를 추가하며 화면에 렌더링한다. 즉, screen A와 B는 같은 root Navigator에 의해 sibling 관계로 widget tree에 추가된다. 문제 발생 원인 Widget tree를 열어보면 DetailScreen과 CounterProvider가 ancestor-descendant 관계가 아닌 sibling 관계인 것을 확인할 수 있음 BuildContext.dependOnInheritedWidgetOfExactType는 widget tree상의 ancestor InheritedWidget을 찾는 것이므로, sibling 관계에서는 접근할 수 없다. HomeScreen에서는 CounterProvider가 direct ancestor widget이기 때문에 CounterProvider에 정상적으로 접근할 수 있었다. 해결 방법 CounterProvider와 DetailScreen을 ancestor-descendant 관계로 만들어 준다.\nHomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 (MaterialApp 위) HomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 관련 코드\nHomeScreen을 아래와 같이 수정한다.\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { // ✅ HomeScreen 하위에 Navigator 추가 // 이제 `Navigator.of(context)`는 이 Navigator를 반환한다. return Navigator( onGenerateRoute: (settings) =\u0026gt; MaterialPageRoute( builder: (context) =\u0026gt; ..., // 원래 widget 덩어리 반환 ), ); } } HomeScreen의 build() method에서 Navigator를 반환한다. Navigator의 onGenerateRoute 함수에서 MaterialPageRoute를 반환한다. MaterialPageRoute의 builder 함수에서 HomeScreen을 구성하는 Scaffold widget 덩어리를 반환한다. 이제 HomeScreen에서 Navigator.of(context)를 호출하면 최상위 Navigator가 아닌 HomeScreen의 하위 Navigator를 사용하므로 DetailScreen이 HomeScreen의 child widget으로 추가된다. InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 관련 코드\nDetailScreen이 MaterialApp 아래에서 InheritedWidget을 child로 갖는 HomeScreen과 sibling 관계를 갖는 것이 문제이므로, InheritedWidget을 MaterialApp의 상위 widget으로 올려서 HomeScreen과 DetailScreen의 공통 ancestor widget이 될 수 있게 만든다.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { // ✅ CounterScope와 CounterProvider가 MaterialApp보다 상위 widget이 된다. return CounterScope( child: MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ `HomeScreen`을 감싸고 있던 CounterScope는 제거한다. home: const HomeScreen(), ), ); } } 이제 HomeScreen과 DetailScreen이 sigling 관계여도 CounterProvider를 공통 ancestor로 가지므로, 두 widget 모두 BuildContext를 통해 CounterProvider에 접근할 수 있다.\n결론 Navigator.of(context)는 MaterialApp이 만드는 최상위 Navigator에 접근한다. Navigator.push는 route widget을 Navigator의 child로 추가한다. 여러 화면에서 공통으로 사용되는 state는 navigation 이후 widget tree 구조를 고려해서 위치시켜야 한다. Navigator를 직접 추가하는 방법은 history를 모르면 예상치 못한 버그가 발생할 우려가 있으므로, InheritedWidget을 Navigator보다 상위에 위치시키는 방법이 더 좋아 보인다. Riverpod에서 ProviderScope가 runApp 바로 아래에서 MyApp을 wrapping하게 만드는 이유를 조금이나마 이해했다. ProviderScope는 내부 build() method에서 InheritedWidget을 상속받는 UncontrolledProviderScope를 반환한다. Riverpod도 비슷한 문제를 해결하기 위해 최상위에 InheritedWidget을 놓으려는 시도를 한 것 같다. 참고 Navigator class | flutter.io MaterialApp class | flutter.io ","permalink":"https://cskime.github.io/posts/inherited-widget-unaccessible/","summary":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider?","title":"Navigator.push로 띄운 route에서 InheritedWidget에 접근할 수 없는 문제"}]