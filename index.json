[{"content":"Summary 셋 모두 Iterable object를 동일한 element를 가진 새 List로 copy할 때 사용할 수 있다. toList()는 List.of의 short-hand method로 서로 같다. List.from은 original Iterable의 element들을 runtime에 result type으로 casting하고, casting에 실패하면 runtime error를 발생시킨다. List.of는 original Iterable의 element들이 result type과 같거나 하위 type인지 compile-time에 check하고, type이 호환되지 않으면 compile-time error를 발생시킨다. List.from은 original Iterable을 down casting할 때 사용할 수 있고, List.of는 up casting할 때 사용할 수 있다. Copy 할 때 original type을 지켜야 한다면 toList() 또는 List.of를 사용하고, type을 변경할 때만 List.from을 사용하자. List.from(elements) elements에 Iterable type을 전달하여 새로운 List 생성 Definition external factory List.from(Iterable elements, {bool growable = true}); elements의 item type을 고려하지 않기 때문에 새로 생성하는 list의 item type을 지정하지 않으면 List\u0026lt;dynamic\u0026gt;으로 생성됨 final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final dynamicList = List.from(nums); print(dynamicList.runtimeType); // List\u0026lt;dynamic\u0026gt; 새로 생성하는 list의 item type을 지정하면 elements의 item type이 type casting됨 final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final numList = List\u0026lt;num\u0026gt;.from(nums); print(numList.runtimeType); // List\u0026lt;num\u0026gt; 새로 생성하는 list의 item type이 runtime에 결정된다. 즉, compile-time에 type check를 하지 않는다. String type인 \u0026quot;3\u0026quot;을 int로 직접 type casting 할 수 없으므로 type error가 발생한다. final nums = [1, 2, \u0026#34;3\u0026#34;]; // List\u0026lt;Object\u0026gt; // TypeError: \u0026#34;3\u0026#34;: type \u0026#39;String\u0026#39; is not a subtype of type \u0026#39;int\u0026#39; final intList = List\u0026lt;int\u0026gt;.from(nums); double type인 3.0은 int로 casting 가능하므로 runtime error가 발생하지 않지만, 여전히 compile time에는 알 수 없다. final nums = [1, 2, 3.0]; // List\u0026lt;num\u0026gt; final intList = List\u0026lt;int\u0026gt;.from(nums); print(intList.runtimeType); // List\u0026lt;int\u0026gt; List.of(elements) elements에 Iterable type을 전달하여 새로운 List 생성 =\u0026gt; 역할은 List.from과 같음 Definition external factory List.of(Iterable\u0026lt;E\u0026gt; elements, {bool growable = true}); elements의 item type과 새로 생성하는 list의 item type이 같으므로, 생성하는 list의 item type을 지정하지 않으면 elements의 item type을 따라간다. final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final = List.of(nums); print(intList.runtimeType); // List\u0026lt;int\u0026gt; 새로 생성하는 list의 item type을 지정하면 elements의 item type도 같은 type이어야 한다. elements에 다른 item type을 가진 list를 전달하면 compile error가 발생한다. final nums = \u0026lt;num\u0026gt;[1, 2, 3]; // List\u0026lt;int\u0026gt; // Error: The argument type \u0026#39;List\u0026lt;num\u0026gt;\u0026#39; can\u0026#39;t be assigned to the parameter type \u0026#39;Iterable\u0026lt;int\u0026gt;\u0026#39;. final intList = List\u0026lt;int\u0026gt;.of(nums); 단, 새로 생성하는 list의 item type이 elements item type의 상위 type이라면 up casting 될 수 있다. final nums = [1, 2, 3]; // List\u0026lt;int\u0026gt; final = List\u0026lt;num\u0026gt;.of(nums); print(intList.runtimeType); // List\u0026lt;num\u0026gt; .toList() List\u0026lt;E\u0026gt; toList({bool growable = true}) =\u0026gt; List\u0026lt;E\u0026gt;.of(this, growable: growable); List.of의 shortcut method List.of로 감싸는 대신 toList()를 사용하는게 더 간단하다. Don\u0026rsquo;t use List.from unless you intent to change the type of the result Effective Dart 문서에서는 result type을 의도적으로 바꾸고 싶을 때만 List.from을 사용하도록 제한한다. 이외에 original Iterable과 result List의 element type이 같은 경우에는 List.of 또는 toList()를 사용한다. List.of도 공통된 상위 type으로 up casting이 가능하지만, original type을 유지하지 않는 경우에는 모두 List.from을 사용하는게 일관성을 지킬 수 있을 것 같다. ","permalink":"https://cskime.github.io/posts/list-of-vs-list-from/","summary":"Summary 셋 모두 Iterable object를 동일한 element를 가진 새 List로 copy할 때 사용할 수 있다. toList()는 List.of의 short-hand method로 서로 같다. List.from은 original Iterable의 element들을 runtime에 result type으로 casting하고, casting에 실패하면 runtime error를 발생시킨다. List.of는 original Iterable의 element들이 result type과 같거나 하위 type인지 compile-time에 check하고, type이 호환되지 않으면 compile-time error를 발생시킨다. List.from은 original Iterable을 down casting할 때 사용할 수 있고, List.of는 up casting할 때 사용할 수 있다. Copy 할 때 original type을 지켜야 한다면 toList() 또는 List.","title":"List.from, List.of, toList() 비교"},{"content":"나는 iOS 개발자로 일하다가 지난 해 퇴사 후 안식년을 갖고 있다. 쉬는 동안 개발자라는 직업에 대한 고민을 많이 하고 있는데, 나는 어떤 개발자가 되고 싶은지 방향성을 잃어가고 있다는 생각이 들었기 때문이다. 개발하는 것 자체는 즐거운 일이지만 개발자라는 직업이 정말 나와 맞는지, 개발자를 오래 할 수 있을지 확신이 들지 않았다. 그래서, 쉬는 동안 다양한 개발 분야를 넓게 경험해보면서 생각을 정리해보고 있다.\nFlutter 10주 스터디 전에도 노마드코더에서 웹 기초 10주 스터디에 참여했던 적이 있다. iOS 개발을 주로 했었기 때문에, 쉬는 동안에는 아예 다른 분야를 경험해보고 싶어서 웹 개발을 선택했다. 웹 개발은 배울 수 있는 곳이 많아서 어디서 강의를 들어볼지 정하기가 어려웠는데, 노마드코더의 강의 스타일과 챌린지 시스템이 마음에 들어서 노마드 코더를 선택했다. 웹 풀스택 개발을 빠르게 경험해볼 수 있다는 것과 어딘가 소속되어 공부할 수 있다는 점도 당시에 스터디에 참여했던 이유 중 하나였다.\n웹 기초 10주 스터디를 졸업한 뒤 노마드코더의 10주 스터디 시스템은 빠르게 지식을 흡수하고 다양한 경험을 해볼 수 있는 가장 좋은 선택지라는 생각이 들었다. 그래서 Flutter를 배워보기로 결정했을 때에도 망섬일 없이 노마드코더의 Flutter 스터디를 선택할 수 있었다. 스터디를 하는 동안 만든 결과물이 약 20개 정도 된다. 꾸준히 강의를 따라가며 만들었던 결과물들을 보니 두 달 반을 헛되게 보낸 건 아니라는 생각이 든다.\nNomadcoders Flutter 10주 스터디 Flutter 10주 스터디 챌린지 결과물 졸업과제 - Apple Music Search 좋았던 점 함께 공부하는 사람들이 있어서 외롭지 않았다. 특히, 일일 스프린트에 올라오는 todo와 주간 회고는 슬럼프가 찾아왔을 때 목표를 잃지 않고 매일 조금씩 꾸준히 공부해 나가는 데 많은 도움이 되었다. 강의를 듣고 챌린지 과제를 하면서 궁금했던 것이나 어려웠던 것을 TA 분들께 바로바로 물어보고 답변을 받을 수 있었다. 다른 스터디원 분들이 올려주시는 코드를 보면서 문제를 해결하는 방법을 다양하게 고민해 볼 수 있었다. 다양한 배경을 가진 스터디원 분들이 색다른 아이디어로 졸업작품을 만들어주셔서 많은 영감을 받았다. 스터디에서만 할 수 있었던 틱톡 클론과 애니메이션 마스터 강의 챌린지 과제들이 많은 도움이 되었다. 기획 요구사항과 UI를 전달받아 개발하는 업무 흐름을 비슷하게 겪어보면서 Flutter로 복잡한 UI를 구현하는 과정에 빠르게 익숙해 질 수 있었다. 아쉬웠던 점 실제로 장소를 빌려 모여서 공부하고 뒤풀이를 하는 오프라인 모각코를 개인 사정으로 두 번 모두 참석하지 못했다. 스터디가 끝난 뒤 오프라인 종강파티도 감기몸살 때문에 참석하지 못했다. 인천 송도에서 Google I/O Extended 행사에 몇몇 스터디원 분들과 함께 참여했지만 컨디션이 좋지 않아서 중간에 따로 나올 수 밖에 없었다. 인사도 제대로 하지 못하고 나와서 아쉬웠다. 배운 점 이전까지는 ChatGPT 같은 GenAI를 개발할 때 사용하는걸 꺼려왔는데, 다른 분들이 ChatGPT를 적절하게 활용해서 완성도 높은 app을 개발하는 것을 보며 편견을 갖고 있다는 걸 느꼈다. 지금부터라도 AI와 함께 개발하는 것을 조금씩 연습해 봐야겠다고 생각했다. 조금씩 매일 하는 것이 가장 중요하다는 것을 다시 한번 느꼈다. 10주 스터디가 중반 이상 넘어가는 시점에는 살짝 루즈해져서 집중하기 어려운 날이 많았지만, 아무리 힘들어도 하루에 10분짜리 강의 한 개라도 꼭 들으려고 노력했다. 이렇게 매일 조금이라도 목표를 달성하는 경험이 쌓여서 10주동안 완강과 과제 개근이라는 결과를 낼 수 있었다. 앞으로 바라는 점 스터디를 통해 Flutter에 익숙해졌으니 스터디가 끝난 뒤에는 평소 생각해 두었던 아이디어를 실제로 개발해 볼 예정이다. iOS 개발 경력과 Flutter 개발 능력을 잘 살려서 Flutter 개발자로 취업할 계획도 갖고 있다. 한번 더 회사에서 일해 보면서 다양한 경험을 쌓아 봐도 좋을 것 같다. ","permalink":"https://cskime.github.io/posts/nomadcoders-flutter-study-review/","summary":"나는 iOS 개발자로 일하다가 지난 해 퇴사 후 안식년을 갖고 있다. 쉬는 동안 개발자라는 직업에 대한 고민을 많이 하고 있는데, 나는 어떤 개발자가 되고 싶은지 방향성을 잃어가고 있다는 생각이 들었기 때문이다. 개발하는 것 자체는 즐거운 일이지만 개발자라는 직업이 정말 나와 맞는지, 개발자를 오래 할 수 있을지 확신이 들지 않았다. 그래서, 쉬는 동안 다양한 개발 분야를 넓게 경험해보면서 생각을 정리해보고 있다.\nFlutter 10주 스터디 전에도 노마드코더에서 웹 기초 10주 스터디에 참여했던 적이 있다.","title":"Nomadcoders Flutter 10주 스터디 후기"},{"content":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod # needed when you reclone your repo (submodules may not get cloned automatically) $ git submodule update --init --recursive Theme update $ git submodule update --remote --merge hugo.yaml에 theme 명시 (구 config.yaml)\ntheme: [\u0026#34;PageMod\u0026#34;] Customizing \u0026lt;img\u0026gt; tag로 post에 image 추가하기 참고 : PaperMod and Hugo tweaks\nhugo.yaml에 아래 설정 추가 markup: goldmark: renderer: unsafe: true # 이 설정이 없으면 \u0026lt;img\u0026gt; tag를 사용할 수 없다. Markdown 문법(![]())을 사용하면 이 설정이 없어도 되지만 image size를 조절할 수 없다. Post 구조를 아래와 같이 변경 contents ㄴ posts ㄴ post-1 ㄴ index.md ㄴ image.jpg Markdown 안에서 \u0026lt;img\u0026gt; tag로 image 추가 \u0026lt;img src=\u0026#34;./image.jpg\u0026#34; width=\u0026#34;300\u0026#34; /\u0026gt; Menu /content 경로에 menu page를 markdown file로 생성 Archive page 설정 Search page 설정 hugo.yaml에 menu 설정 추가 (참고) Deploy to GitHub Repository 두 개 생성 (실제로 website로 보여지는 파일들은 /public에 있으므로 저장소 분리)\nblog source : blog source를 upload할 repository {username}.github.io : public directory를 upload할 repository Remote repo로 추가\n# blog source repository $ git remote add origin https://github.com/username/blog-source.git # public directory만 submodule로 따로 관리 $ git submodule add -b main https://github.com/username/username.github.io.git public # Submodule 등록 확인 $ ll .git/modules submodule에 theme과 public directory 두 개가 등록되어 있다면 정상적으로 등록된 것 만약, fatal: 'public' already exists and is not a valid git repo 과 같은 error가 발생하면 public 폴더를 삭제한 뒤 재시도 Root와 /public에서 각각 git remote -v를 실행하면 서로 다른 repository가 등록되어 있는 것을 확인 배포 script\n블로그를 배포할 때 blog-source와 {username}.github.io 두 repository에 각각 push해야 함 배포 과정을 script로 작성해서 사용 (참고) Reference Hugo Documentation PaperMod\u0026rsquo;s Demo hugo-PaperMod WiKi PaperMod 테마를 Hugo 사이트에 적용하는 방법 Hugo 블로그 생성 과정 (theme PaperMod) ","permalink":"https://cskime.github.io/posts/github-pages-hugo-papermod-blog/","summary":"GitHub Pages 블로그를 Hugo PaperMod 테마를 사용해서 블로그를 만든 방법을 기록해 둔다. [PaperMod WiKi - Installation] 문서와 블로그를 참고했다.\nInstallation Hugo 설치 및 site 생성 (작성일 기준 최신 버전 테마는 Hugo 버전 v0.112.4 이상 필요)\n$ brew install hugo $ hugo new site MyFreshWebsite --format yaml Theme 설치 (권장 방식인 git submodule 사용)\n# Initialize git repository $ git init \u0026amp;\u0026amp; git commit -am \u0026#34;initial commit\u0026#34; # Install theme $ git submodule add --depth=1 https://github.","title":"GitHub Pages와 Hugo PaperMod 테마로 블로그 만들기"},{"content":" Swift에서는 as?로 안전하게 type casting을 할 수 있었다.\nclass A {} class B: A {} class C {} let a = A() let b = B() b as? C// nil Dart는 as keyword로 type casting을 할 수 있지만, incompatible type으로 casting을 시도하면 type error가 발생한다. Dart에는 optional casting 연산자가 따로 없으므로, error 없이 type casting을 하려면 type check를 먼저 해야 한다.\nclass A {} class B extends A {} class C {} final a = A(); final b = B(); a as C // ❗️ type error if (a is C) { a as C // Never executed } if (a is B) { a as B // ✅ OK } 매번 type check를 하려면 번거로우므로, 아래와 같은 extension을 만들어서 사용하면 편리하다.\nextension SafeTypeCast on Object? { T? asOrNull\u0026lt;T\u0026gt;() { var self = this; return self is T ? self : null; } } a.asOrNull\u0026lt;B\u0026gt;();// OK 참고 https://github.com/dart-lang/language/issues/399 https://www.dhiwise.com/post/the-ultimate-guide-to-dart-type-cast-converting-data-types ","permalink":"https://cskime.github.io/posts/dart-safe-type-cast/","summary":"Swift에서는 as?로 안전하게 type casting을 할 수 있었다.\nclass A {} class B: A {} class C {} let a = A() let b = B() b as? C// nil Dart는 as keyword로 type casting을 할 수 있지만, incompatible type으로 casting을 시도하면 type error가 발생한다. Dart에는 optional casting 연산자가 따로 없으므로, error 없이 type casting을 하려면 type check를 먼저 해야 한다.\nclass A {} class B extends A {} class C {} final a = A(); final b = B(); a as C // ❗️ type error if (a is C) { a as C // Never executed } if (a is B) { a as B // ✅ OK } 매번 type check를 하려면 번거로우므로, 아래와 같은 extension을 만들어서 사용하면 편리하다.","title":"Dart에서 type casting을 안전하게 하는 방법"},{"content":"개발 동기 노마드코더 챌린지 과제 중 아래와 같은 text UI를 구현하는 부분이 있었다. 회원가입 중 이용 약관이나 개인 정보 처리 방침 등을 사용자에게 안내하고 관련 외부 문서로 이동하여 확인할 수 있게 만드는 보편적인 UI 이다.\nFlutter에서 text에 다양한 style을 적용할 때 RichText 또는 Text.rich를 사용하므로, 이 UI를 구현하기 위해 아래와 같이 코드를 작성했다.\n이렇게 코드를 작성하면 몇 가지 문제가 있다.\n다른 style을 사용할 text를 직접 분류해서 나누어 작성해야 하므로 실수할 가능성이 있다. TextSpan이 중첩되는 구조이므로 어떤 text에 다른 style을 적용하는지 직관적으로 파악하기 어려워서 요구사항이 바뀌면 유지보수하기 어렵다. TextSpan을 어떻게, 얼마나 중첩시켜야 하는지에 대한 기준이 없다. 코드를 일관되게 작성하기 어렵다. 첫 번째 TextSpan.children에 다른 모든 TextSpan을 넣어도 동작에 차이가 없으므로, 사람에 따라 다른 style로 코드를 작성하게 된다. 만약, grouping 할 목적으로 두 번 이상 중첩한다면 indent depth가 깊어져 가독성이 떨어진다. 이런 문제를 해결하고 최대한 단순하고 직관적으로 구현할 수 있는 방법을 고민해 보다가, 이런 종류의 text UI를 쉽게 만들 수 있는 widget을 직접 만들어보기로 했다.\n설계 아래 세 가지 단계로 개발할 수 있게 되는 것을 목표로 한다.\n전체 문장을 주고, style을 바꾸고 싶은 단어 목록을 전달하면, 전체 문장에서 해당 단어들을 찾아 지정한 style 적용 이를 위해, text를 rendering하는 widget은 constructor를 통해 아래 속성을 초기화한다.\ntext : 전체 text (String type) words : style을 바꾸고 싶은 단어 목록 여기서 words는 List\u0026lt;Word\u0026gt; type의 값을 받는다. Word 객체는 constructor로 두 가지 값을 초기화한다.\ntext : 단어 (String type) style : 단어에 적용할 style 결과적으로, 아래와 같이 사용하는 것을 목표로 한다.\nMyTextWidget( text: \u0026#34;This is an entire text.\u0026#34;, words: [ Word(text: \u0026#34;entire\u0026#34;, style: TextStyle(~)), Word(text: \u0026#34;text\u0026#34;, style: TextStyle(~)), ], ) 개발 과정 1차 개발 처음에는 특정 단어를 선택하면 그에 해당하는 외부 web page로 이동할 수 있도록 개발했다.\n단어에 하이퍼링크를 추가하는 것임을 나타내기 위해 Link라는 class를 만들고, 해당 단어를 선택했을 때 외부에서 web page로 이동하는 코드를 작성할 수 있도록 constructor를 통해 callback 함수를 등록하도록 개발했다. 그리고, 전체 text와 하이퍼링크를 걸 단어 목록 List\u0026lt;Link\u0026gt;를 전달받아 Link에 해당하는 단어들에 style을 입히고 callback 함수를 등록해 주는 LinkableText class를 구현했다.\nLinkableText은 아래 과정을 거쳐 Link.text에 해당하는 단어들에 style을 적용하고 callback을 등록한다.\nlinks로 전달된 단어들을 순회하며 전체 text에서 해당 단어들의 위치(index) 저장 Index를 기준으로 links를 오름차순 정렬 links로 전달하는 단어들이 전체 text에 나타나는 순서와 다른 경우를 고려하여 정렬 정렬된 단어들을 순회하며 전체 text를 기준으로 split Split된 단어들과 links 단어들을 번갈아가며 List\u0026lt;TextSpan\u0026gt;에 저장 생성된 List\u0026lt;TextSpan\u0026gt;으로 Text.rich를 만들어서 반환 최종적으로 구현된 LinkableText와 Link는 아래와 같이 사용할 수 있다.\n2차 개발 LinkableText는 대부분의 경우 의도한 대로 잘 동작하지만, links에 같은 단어가 두 번 이상 들어있는 경우 특정 위치의 단어에만 style을 적용하기 어렵다는 단점이 있었다. 가령, 두 번째 나타나는 단어에만 style을 적용하려는 경우에도 첫 번째 나타나는 단어가 links에 들어있어야 한다. Style을 적용하지 않을 단어는 links에 추가하지 않았으면 좋겠다.\n또, “Link”라는 이름에 비해 기능이 너무 추상적이기도 했다. URL에 대한 하이퍼링크를 만드는게 아니라, text에 부분적으로 style을 적용하고 tap 할 수 있는 기능을 추가하는 것에 가깝다.\n이런 문제점을 개선하고 더 범용적으로 사용될 수 있도록 추상화한 CustomizableText widget을 개발하고, style을 더 세밀하게 변경할 수 있도록 인터페이스를 추가했다.\n변경 사항은 아래와 같다.\n이름에서 “link” 제거 LinkableText → CustomizableText links → customizes Link → CustomText span (new) callback → onTap Style을 설정할 수 있는 속성 추가 (아래로 갈 수록 style이 override 된다.) CustomizableText.style : 전체 text에 적용되는 style CustomizableText.customStyle : 전체 custom text들에 적용되는 style CustomText.style : custom text 1개에 적용되는 style 특정 위치의 text에만 style을 적용할 수 있도록 개선 span 값을 사용해서 특정 위치의 단어에만 style을 적용할 수 있도록 개선했다. span으로 전체 text에서 두 번 이상 나타나는 단어 중 임의의 위치에 있는 단어를 식별할 수 있다. 이 기능은 기존 LinkableText에서 style을 적용하지 않을 단어까지 links에 넣어야 하는 문제를 해결한다. 내부 정렬 알고리즘을 개선했습니다. Before : Map으로 단어 별 index들을 기록한 뒤 정렬 After : allMatches method를 사용해서 단어들의 정렬된 index를 얻음 Closing CustomizableText를 사용하여 위와 같은 text UI를 직관적이고 쉽게 그릴 수 있었다. CustomizableText는 어떤 프로젝트에서도 다양하게 활용될 수 있을 것 같아서 pub.dev에 배포하는 경험도 할 수 있었다. (customizable_text package | pub.dev)\n배포를 하고 나서 개선할 것들이 더 눈에 띄었다. pub.dev에 패키지를 올리면 score가 매겨지는데, documentation이 부족하여 만점을 받지 못했다. Package로 만든 이상, API documentation을 제대로 해 두는게 필요해 보였다. 또, tap 외에도 long press 등 다른 gesture에 대한 callback을 추가할 수 있으면 더 좋을 것 같다. Static color가 아닌 gradient나 shadow 등 다른 형태의 style을 입힐 수 있게 만들어도 좋을 것 같다.\n","permalink":"https://cskime.github.io/posts/customizable_text_package_review/","summary":"개발 동기 노마드코더 챌린지 과제 중 아래와 같은 text UI를 구현하는 부분이 있었다. 회원가입 중 이용 약관이나 개인 정보 처리 방침 등을 사용자에게 안내하고 관련 외부 문서로 이동하여 확인할 수 있게 만드는 보편적인 UI 이다.\nFlutter에서 text에 다양한 style을 적용할 때 RichText 또는 Text.rich를 사용하므로, 이 UI를 구현하기 위해 아래와 같이 코드를 작성했다.\n이렇게 코드를 작성하면 몇 가지 문제가 있다.\n다른 style을 사용할 text를 직접 분류해서 나누어 작성해야 하므로 실수할 가능성이 있다.","title":"Flutter Package 개발 기록 - customizable_text"},{"content":"Flutter Constraint와 Layout Flutter는 3단계를 거쳐 widget의 layout을 결정한다.\nConstraints go down : Parent widget이 child widget에 constraint를 제안한다. Sizes go up : Child widget은 constraint 범위 내의 size를 parent widget에 알려준다. Parent sets position : Parent widget은 자신의 alignment 정보와 child widget size를 사용해서 child widget의 position을 결정한다. 여기서 \u0026ldquo;constraint\u0026ldquo;란 size의 최대 ~ 최소값의 범위를 말한다. Flutter에서는 BoxConstraints class를 주로 사용하여 minWidth, minHeight, maxWidth, maxHeight을 정의한다.\nconst BoxConstraints({ this.minWidth = 0.0, this.maxWidth = double.infinity, this.minHeight = 0.0, this.maxHeight = double.infinity, }); 여기서 주의할 점은, constraint는 size의 범위를 제한하는 것이므로 child widget의 size 또한 이 constraint 범위 안에 있어야 한다는 것이다. Child widget size가 parent가 제안한 constraint 범위를 벗어나면 \u0026ldquo;A RenderFlex overflowed\u0026hellip;\u0026rdquo; error가 발생한다.\nTight vs loose constraints Tight constraint min == max인 경우로, exact size를 갖게 만든다. BoxConstraints.tight(Size size) : minWidth = size.width, maxWidth = size.width, minHeight = size.height, maxHeight = size.height; App widget은 child widget을 전체 screen에 딱 맞게 만드는데, screen size에 대한 tight constraint가 적용된 것임 Loose constraint min == 0 \u0026lt; max인 경우로, child widget이 범위 내에서 own size를 가질 수 있게 한다. Center widget은 parent로부터 받은 tight constraint를 loose constraint로 바꿔서 child에 전달하는 목적이기도 함 Bounded vs Unbounded Bounded constraint max \u0026lt; infinity인 경우 Widget 크기가 min ~ max 범위 안에서 결정됨 Unbounded constraint max == infinity인 경우 Size 제약이 없는 상태이므로 box는 가능한 최대 size로 커지려고 한다. Column, Row 같은 Flex box 또는 ListView, ScrollView subclass들 같은 scrollable region이 unbounded constraint를 갖는다. 발생할 수 있는 문제 ListView의 scroll 영역은 main axis 방향으로 무한대 크기를 허용함 children중 main axis와 같은 방향으로 크기가 무한대로 확장하는 widget이 있다면 unbound layout error가 발생한다. e.g. 크기가 고정되지 않은 ListView 안에서 Column, Row 등 flexible widget 사용 둘 중 하나는 SizedBox로 크기를 고정하거나 BoxConstraint로 제약을 추가해야 한다. Flutter Widgets들의 Size 규칙 Flutter widget들이 size를 결정하는 규칙은 아래와 같다.\n가능한 영역을 꽉 채우는 size를 사용하는 widget (e.g. Center, Align, ListView) Child widget과 동일한 size를 사용하는 widget (e.g. Transform, Opacity) Content size를 사용하는 widget (e.g. Image, Text) 특히, Container widget은 어떤 속성을 사용하는지에 따라 동작하는 방식이 달라진다.\n기본적으로 가능한 영역을 꽉 채우는 size를 사용한다. (1번) width, height 등 size가 지정되면 해당 size를 사용한다. (3번) child widget을 갖는 경우, child widget size를 사용한다. (2번) Reference Understanding constraints | Flutter Dev Flutter의 제약(constraint) 이해하기 | Tistory ","permalink":"https://cskime.github.io/posts/flutter-constraints/","summary":"Flutter Constraint와 Layout Flutter는 3단계를 거쳐 widget의 layout을 결정한다.\nConstraints go down : Parent widget이 child widget에 constraint를 제안한다. Sizes go up : Child widget은 constraint 범위 내의 size를 parent widget에 알려준다. Parent sets position : Parent widget은 자신의 alignment 정보와 child widget size를 사용해서 child widget의 position을 결정한다. 여기서 \u0026ldquo;constraint\u0026ldquo;란 size의 최대 ~ 최소값의 범위를 말한다. Flutter에서는 BoxConstraints class를 주로 사용하여 minWidth, minHeight, maxWidth, maxHeight을 정의한다.\nconst BoxConstraints({ this.minWidth = 0.","title":"Flutter Constraint 이해하기"},{"content":"문제 상황 ListView를 Clip.none으로 설정하면 item들이 scroll될 때 ListView의 실제 영역을 벗어나서 화면 밖으로 사라질 때 까지 화면에 유지될 것이라고 예상 하지만 실제로는 item이 화면 밖으로 나가기 전에 먼저 화면에서 사라짐 이 ListView는 Padding 및 다른 widget들의 하위 widget 원인 분석 Flutter GitHub에 이미 같은 문제로 issue가 올라왔었다. 이 repo의 contributor에 따르면, 이것은 의도된 동작이라고 한다. it looks like this is working as intended.. The Padding around the ListView is what is causing this effect. The padding makes the viewport of the ListView smaller, although it is not visibly apparent. Then with Clip.none set, the bounds of that viewport are not clipped, so you can see as the items exit they are disposed since they are outside of the actual scrolling window due to the Padding.\n즉, ListView나 PageView같은 scrollable widget들의 item이 화면에서 사라지는 시점은 screen 밖으로 나갈 때가 아닌 \u0026ldquo;해당 widget의 viewport 밖으로 완전히 나갈 때\u0026ldquo;이다. 문제 상황에서 item이 사라지는 지점도 ListView 영역을 완전히 벗어나는 지점과 일치한다. 문제 해결 ListView item들이 화면 밖으로 완전히 나갈 때 까지는 화면에 표시되기를 원하므로, ListView의 viewport가 screen size와 동일하게 만들어주면 문제를 해결할 수 있다. ListView를 감싸고 있는 Padding widget이 horizontal inset을 갖지 않게 만들고, padding 역할을 하는 빈 widget을 ListView의 양 끝에 추가해 준다. 이제 ListView의 viewport와 screen size가 같으므로 item이 화면 밖으로 나갈 때 까지 화면에 보여진다. ","permalink":"https://cskime.github.io/posts/listview-clip-item-disappear/","summary":"문제 상황 ListView를 Clip.none으로 설정하면 item들이 scroll될 때 ListView의 실제 영역을 벗어나서 화면 밖으로 사라질 때 까지 화면에 유지될 것이라고 예상 하지만 실제로는 item이 화면 밖으로 나가기 전에 먼저 화면에서 사라짐 이 ListView는 Padding 및 다른 widget들의 하위 widget 원인 분석 Flutter GitHub에 이미 같은 문제로 issue가 올라왔었다. 이 repo의 contributor에 따르면, 이것은 의도된 동작이라고 한다. it looks like this is working as intended.. The Padding around the ListView is what is causing this effect.","title":"ListView에 Clip.none 설정 시 item이 사라지는 문제"},{"content":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider? of(BuildContext context) =\u0026gt; context.dependOnInheritedWidgetOfExactType\u0026lt;CounterProvider\u0026gt;(); } 공유 상태를 관리하기 위한 StatefulWidget 생성\nclass CounterScope extends StatefulWidget { const CounterScope({ super.key, required this.child, }); final Widget child; @override State\u0026lt;CounterScope\u0026gt; createState() =\u0026gt; _CounterScopeState(); } class _CounterScopeState extends State\u0026lt;CounterScope\u0026gt; { // ✅ 실제 상태 값 관리 : 상태 저장 및 갱신(setState) int counter = 0; void incrementCounter() { setState(() { counter++; }); } @override Widget build(BuildContext context) { return CounterProvider( counter: counter, incrementCounter: incrementCounter, child: widget.child, ); } } MyApp의 home에서 CounterScope를 HomeScreen의 상위 widget으로 추가\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ CounterScope가 HomeScreen의 상위 widget이 됨 home: const CounterScope(child: HomeScreen()), ); } } 문제 재현 HomeScreen에서는 CounterProvider에 접근할 수 있음\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: ..., body: Center( child: CountLabel( counter: CounterProvider.of(context)?.counter ?? -1, // ✅ ), ), floatingActionButton: IncrementButton( onPressed: CounterProvider.of(context)?.incrementCounter, // ✅ ), ); } } Navigator.push로 DetailScreen으로 이동\n// 버튼 callback onPressed: () =\u0026gt; Navigator.of(context).push( MaterialPageRoute( builder: (context) =\u0026gt; const DetailScreen(), ), ), DetailScreen에서는 CounterProvider에 접근할 수 없음\n// 버튼 callback class DetailScreen extends StatelessWidget { const DetailScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( backgroundColor: Theme.of(context).colorScheme.inversePrimary, title: const Text(\u0026#39;Detail Page\u0026#39;), ), body: Center( child: CountLabel( // ❌ : null을 반환하므로 label에 \u0026#39;-1\u0026#39; 표시 counter: CounterProvider.of(context)?.counter ?? -1, ), ), floatingActionButton: IncrementButton( // ❌ : null을 반환하므로 counter가 동작하지 않음 onPressed: CounterProvider.of(context)?.incrementCounter, ), ); } } 원인 분석 InheritedWidget에 접근하는 방식 BuildContext.dependOnInheritedWidgetOfExactType은 현재 widget에서 widget tree상의 상위 widget을 찾아서 반환함 즉, BuildContext.dependOnInheritedWidgetOfExactType이 null이면 widget tree에서 상위에InheritedWidget이 존재하지 않는다는 것 Navigator.of(context).push의 동작 방식 MaterialApp은 내부에서 Navigator를 만들고 widget tree에 추가한다. MaterialApp.home에 전달하는 widget은 이 최상위 Navigator의 child widget이 된다. MaterialApp ㄴ Navigator ㄴ HomeScreen Widget에서 Navigator.of(context)을 호출하면 MaterialApp이 생성한 최상위 Navigator를 얻는다. Screen A에서 screen B로 Navigator.push를 통해 화면을 전환하면, 최상위 Navigator의 하위에 screen B를 추가하며 화면에 렌더링한다. 즉, screen A와 B는 같은 root Navigator에 의해 sibling 관계로 widget tree에 추가된다. 문제 발생 원인 Widget tree를 열어보면 DetailScreen과 CounterProvider가 ancestor-descendant 관계가 아닌 sibling 관계인 것을 확인할 수 있음 BuildContext.dependOnInheritedWidgetOfExactType는 widget tree상의 ancestor InheritedWidget을 찾는 것이므로, sibling 관계에서는 접근할 수 없다. HomeScreen에서는 CounterProvider가 direct ancestor widget이기 때문에 CounterProvider에 정상적으로 접근할 수 있었다. 해결 방법 CounterProvider와 DetailScreen을 ancestor-descendant 관계로 만들어 준다.\nHomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 (MaterialApp 위) HomeScreen 하위 Navigator가 DetailScreen을 push 하도록 수정 관련 코드\nHomeScreen을 아래와 같이 수정한다.\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { // ✅ HomeScreen 하위에 Navigator 추가 // 이제 `Navigator.of(context)`는 이 Navigator를 반환한다. return Navigator( onGenerateRoute: (settings) =\u0026gt; MaterialPageRoute( builder: (context) =\u0026gt; ..., // 원래 widget 덩어리 반환 ), ); } } HomeScreen의 build() method에서 Navigator를 반환한다. Navigator의 onGenerateRoute 함수에서 MaterialPageRoute를 반환한다. MaterialPageRoute의 builder 함수에서 HomeScreen을 구성하는 Scaffold widget 덩어리를 반환한다. 이제 HomeScreen에서 Navigator.of(context)를 호출하면 최상위 Navigator가 아닌 HomeScreen의 하위 Navigator를 사용하므로 DetailScreen이 HomeScreen의 child widget으로 추가된다. InheritedWidget의 위치를 최상위 Navigator의 ancestor로 변경 관련 코드\nDetailScreen이 MaterialApp 아래에서 InheritedWidget을 child로 갖는 HomeScreen과 sibling 관계를 갖는 것이 문제이므로, InheritedWidget을 MaterialApp의 상위 widget으로 올려서 HomeScreen과 DetailScreen의 공통 ancestor widget이 될 수 있게 만든다.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { // ✅ CounterScope와 CounterProvider가 MaterialApp보다 상위 widget이 된다. return CounterScope( child: MaterialApp( title: \u0026#39;Navigator Inherited Example\u0026#39;, theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), useMaterial3: true, ), // ✅ `HomeScreen`을 감싸고 있던 CounterScope는 제거한다. home: const HomeScreen(), ), ); } } 이제 HomeScreen과 DetailScreen이 sigling 관계여도 CounterProvider를 공통 ancestor로 가지므로, 두 widget 모두 BuildContext를 통해 CounterProvider에 접근할 수 있다.\n결론 Navigator.of(context)는 MaterialApp이 만드는 최상위 Navigator에 접근한다. Navigator.push는 route widget을 Navigator의 child로 추가한다. 여러 화면에서 공통으로 사용되는 state는 navigation 이후 widget tree 구조를 고려해서 위치시켜야 한다. Navigator를 직접 추가하는 방법은 history를 모르면 예상치 못한 버그가 발생할 우려가 있으므로, InheritedWidget을 Navigator보다 상위에 위치시키는 방법이 더 좋아 보인다. Riverpod에서 ProviderScope가 runApp 바로 아래에서 MyApp을 wrapping하게 만드는 이유를 조금이나마 이해했다. ProviderScope는 내부 build() method에서 InheritedWidget을 상속받는 UncontrolledProviderScope를 반환한다. Riverpod도 비슷한 문제를 해결하기 위해 최상위에 InheritedWidget을 놓으려는 시도를 한 것 같다. 참고 Navigator class | flutter.io MaterialApp class | flutter.io ","permalink":"https://cskime.github.io/posts/inherited-widget-unaccessible/","summary":"문제 상황 상위 위젯에서 추가한 InheritedWidget을 하위 widget에서 접근하지 못하는 문제 BuildContext.dependOnInheritedWidgetOfExactType이 null을 반환해서 property 및 method를 호출할 수 없음 예제 코드 문제를 재현하는 간단한 counter app\nHomeScreen 및 DetailScreen은 버튼을 눌러서 count 증가\nHomeScreen과 DetailScreen은 count 값(state) 공유\nCount 값을 하위 widget에 공유하기 위한 InheritedWidget 생성\nclass CounterProvider extends InheritedWidget { const CounterProvider({ super.key, required super.child, required this.counter, required this.incrementCounter, }); final int counter; // ✅ count 값 공유 final void Function() incrementCounter; // ✅ count action 공유 @override bool updateShouldNotify(covariant InheritedWidget oldWidget) =\u0026gt; true; static CounterProvider?","title":"Navigator.push로 띄운 route에서 InheritedWidget에 접근할 수 없는 문제"},{"content":"Hit Testing Hit test는 사용자 event가 발생할 때 view 계층(hierarchy)에서 subview들을 탐색(traverse)하며 event를 처리할 view를 결정하는 과정이다. Root view부터 시작하여 subview들을 역방향으로 탐색하며, event 발생 위치(point)를 포함하는 view가 있다면 그 view의 subview들을 같은 방법으로 탐색해 나간다.\n\u0026lsquo;역방향\u0026rsquo;으로 탐색하는 이유는, 화면의 가장 앞에 위치한 view부터 탐색하기 위함이다. 여러 개의 view가 겹쳐있다면 사용자가 보게 되는 맨 앞의 view가 event를 가져가야 한다. 화면의 가장 앞에 있는 view는 다음과 같은 특징을 가진다.\nz-order index(depth)가 가장 크다. 형제 view(sibling view)들 중에서 subview index가 가장 크다. Tree 구조에서 이와 같은 탐색 방법을 **역방향 깊이 우선 탐색(Reverse Pre-Order Depth-First Traversal)**이라고 한다.\n아래 그림은 touch event가 발생했을 때 event를 처리할 view를 결정하는 과정을 보여준다.\nView 계층의 root view(UIWindow)부터 시작하여 touch point를 포함하는 subview들 중 가장 멀리 떨어진 view를 탐색한다. MainView의 subview들 중 index가 가장 큰 View C부터 탐색을 시작한다. View C는 touch point를 포함하지 않으므로 건너뛰고, View B를 탐색한다. View B는 touch point를 포함하고 있으므로, 그 subview들 중 index가 가장 큰 View B.2를 탐색한다. View B.2는 touch point를 포함하지 않으므로 건너뛰고, view B.1을 탐색한다. View B.1은 touch point를 포함하고 root로부터 가장 멀리 떨어진 view이므로, View B.2에 event를 전달한다. Hit Test 구현 Hit testing에서 event를 전달받을 후보 view가 되기 위해서는 다음 조건을 만족해야 한다.\nView가 화면에 보여야 한다. View가 user interaction이 가능해야 한다. View 영역이 event 발생 위치(point)를 포함해야 한다. View 계층에서 세 가지 조건을 만족하는 view를 찾기 위해 hitTest(_:with:) 함수를 다음과 같이 구현할 수 있다. 함수가 nil을 반환하는 것은 event를 받을 수 없는 view이므로 다음 view를 탐색하라는 의미이다.\nfunc hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // 1번 조건 검사 guard !isHidden, alpha \u0026gt; 0.01 else { return nil } // 2번 조건 검사 guard isUserInteractionEnabled else { return nil } // 역방향 탐색을 위해 subviews array를 뒤집어서(reversed) 탐색 for subview in subviews.reversed() { let point = subview.convert(point, from: self) guard let hitView = subview.hitTest(point, with: event) else { continue } // 재귀적으로 반환되는 hitView는 곧 subview를 의미한다. // 즉, subview에서 hit testing이 성공하면 subview가 자기 자신을 반환할 것이다. return hitView } // 3번 조건 검사 guard bounds.contains(point) else { return nil } return self } UIView에는 이런 방식으로 구현된 hitTest(_:with:) method가 이미 구현되어 있다. 만약, 어떤 view가 특정 조건에서 event를 수신하지 못하게 하려면 다음과 같이 override해서 사용할 수 있다.\nclass SomeView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // somCondition이 true일 때만 이 view에서 hit testing을 계속한다. guard someCondition else { return nil } return super.hitTest(point, with: event) } } 활용 Hit testing에서 반환되는 view를 조작하여 특정 상황에서만 event를 받을 수 있도록 구현할 수 있다.\n1. Passing through touch event 아래와 같이 5개의 UISwitch가 파란색 view로 덮여 있다. 스위치를 터치하더라도, 덮고 있는 view가 event를 가져가므로 스위치를 on/off할 수 없다.\n이 상황에서 스위치를 터치해서 on/off할 수 있게 만들려면, cover view에 event가 전달되지 않아야 하므로 event를 받기 위한 3가지 조건 중 한 가지를 만족하지 않도록 바꾸면 된다.\nUser interaction 비활성화 coverView.isUserInteractionEnabled = false View 숨김(Cover view가 반드시 보여야한다면, 이 방법은 사용하지 못할 것이다.) coverView.isHidden = true // or coverView.alpha = 0 hitTest(_:with:) 함수에서 nil 반환 class CoverView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { return nil } } 만약 특정 스위치만 on/off할 수 있게 만들려면 hitTest(_:with:) method를 override해서 nil을 반환하는 조건을 추가로 구현해야 한다.\nclass CoverView: UIView { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { var hitView = super.hitTest(point, with: event) // 가운데 스위치가 있는 영역 let rect = bounds.insetBy(dx: bounds.width / 3, dy: bounds.height / 3) // Point가 가운데 영역(rect)에 포함될 때는 nil을 반환한다. guard rect.contains(point) else { return hitView } return nil } } 2. Throw touch event Hit testing을 통해 event를 받는 view는 hitTest(_:with:) method에서 반환되는 view이다. 즉, 실제로는 event를 받기 위한 3가지 조건을 만족하지 못하는 어떤 view를 임의로 hitTest(_:with:)에서 반환시키면 그 view도 event를 받아 처리할 수 있게 된다.\n다음은 이 방법을 사용하여 크기가 작은 버튼의 터치 영역을 확장시키는 예시이다.\nclass CustomButton: UIButton { override func hitTest(_ point: CGPoint, with event: UIEvent?) -\u0026gt; UIView? { // Button 영역에서 상하좌우 10pt만큼 더 넓은 영역까지 touch point를 검사한다. let contains = bounds.insetBy(dx: -10, dy: -10).contains(point) return contains ? super.hitTest(point, with: event) : nil } } Reference http://smnh.me/hit-testing-in-ios/ https://developer.apple.com/documentation/uikit/uiview/1622469-hittest ","permalink":"https://cskime.github.io/posts/ios-hit-testing/","summary":"Hit Testing Hit test는 사용자 event가 발생할 때 view 계층(hierarchy)에서 subview들을 탐색(traverse)하며 event를 처리할 view를 결정하는 과정이다. Root view부터 시작하여 subview들을 역방향으로 탐색하며, event 발생 위치(point)를 포함하는 view가 있다면 그 view의 subview들을 같은 방법으로 탐색해 나간다.\n\u0026lsquo;역방향\u0026rsquo;으로 탐색하는 이유는, 화면의 가장 앞에 위치한 view부터 탐색하기 위함이다. 여러 개의 view가 겹쳐있다면 사용자가 보게 되는 맨 앞의 view가 event를 가져가야 한다. 화면의 가장 앞에 있는 view는 다음과 같은 특징을 가진다.\nz-order index(depth)가 가장 크다.","title":"iOS Hit Testing"}]